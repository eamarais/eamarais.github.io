<!doctype html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Object Re-entry Emissions</title>

	<link rel="stylesheet" href="style.css" type="text/css" media="screen" />
	<style>
		#page { background: url("./themes/default/images/kubrickbgwide.jpg") repeat-y top; border: none; }
	</style>

	<script src="https://cdn.plot.ly/plotly-3.0.3.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/globe.gl"></script>
	<script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.js"></script>

	<!-- Google tag (gtag.js) -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-L03HTPL2E2"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());
		gtag('config', 'G-L03HTPL2E2');
	</script>

</head>

<body>

<div id="page">
	
<div id="header">

	<!--Header image-->
	<div id="headerimg">
		<h1>
			<a style="color:black" href="http://maraisresearchgroup.co.uk/">
				<div class="transparent-box">Atmospheric Composition and Air Quality Group</div>
			</a>
		</h1>
		<div class="description"></div>
	</div>

<!--Navigation bar-->
	<div id="navmenu">
		<iframe src="./nav.html" onload="this.before((this.contentDocument.body||this.contentDocument).children[0]);this.remove()"></iframe>
	</div>

</div>

<hr />

<div id="content" class="widecolumn">

	<div class="post" id="post-3">
		<h2 style="text-transform: none;
				   margin-top: 20px;
				   margin-bottom: 20px;
				   font-size: 3.2em;
				   font-weight: 500;
				   line-height: 1.2em;">
            Emissions from Artificial Object Re-entries
</h2>
				<div class="entry">	
				
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.css">
					
	<style>

		.filter-container {
			display: flex;
			justify-content: space-around;
			align-items: center;
			padding: 10px 0px 20px 0px;
			gap: 10px;
		}

		.filter {
			position: relative;
			background: #143d59;
			color: whitesmoke;
			padding: 0.25rem;
			height: 15px;
			cursor: pointer; /* show pointer on hover */
		}

		.filter label {
			font-size: 1.2em;
			user-select: none;
			display: inline-flex;
			align-items: center;
			gap: 6px;
			position: relative;
		}

		.filter label::after {
			content: '';
			display: inline-block;
			width: 0; 
			height: 0; 
			border-left: 5px solid transparent;
			border-right: 5px solid transparent;
			border-top: 5px solid whitesmoke;
			vertical-align: middle;
			transition: transform 0.3s ease;
			margin-left: 6px;
		}

		/* Arrow down (open) */
		.filter.open label::after {
			transform: rotate(180deg);
		}

		/* Remove any arrows from dropdown labels */
		.dropdown label::after {
			display: none !important;
			content: none !important;
		}
		/* Hide dropdown initially */
		.dropdown ul {
			display: none;
			position: absolute;
			left:50%;
			transform: translateX(-50%);
			list-style-type: none;
			background-color: #8dc4ee;
			max-height: 300px;
			overflow-y: auto;
			width: auto;
			min-width: 150px; /* Ensure a minimum width */
			white-space: nowrap;
			border-radius: 5px;
			z-index: 100;
			top: 15px;
		}

		.dropdown label {
			font-size: 1.2em;
			display: flex;
			align-items: center;
			gap: 15px;
			padding: 0;
		}

			.filter.open .dropdown ul {
			display: block;
			padding: 0px;
		}

		.entry ul li:before {
  			display: none;
		}

		html>body .entry li {
			margin: 7px 0 7px 0;
		}

		.wrap-text {
			white-space: normal;
			word-wrap: break-word;
			max-width: 500px; /* Adjust the width as needed */
		}
		
		/* Container to align the maps side by side */
		.map-container .globe-container .bar-container {
			display: flex;
			width: 100%; /* or set a specific width like 80% if desired */
			height: 100%; /* You can adjust this as needed */
		}

		#bar {
			flex: 1;
			max-width: 25%;
			height: 100%;
			max-height: 100%;
		}

		#map {
			width: 100%;
			height: 100%;  /* or 100%, or whatever fits your layout */
			margin: 0;
			padding: 0;
		}

		#stack {
			flex: 3;
			max-width: 75%;
		}

        /* Style for the tabs */
        .tabs {
            display: flex;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .tab {
            padding: 5px 5px;
            margin-right: 10px;
            background-color: #143d59;
            border: 1px solid #ccc;
            border-radius: 5px;
			color: whitesmoke;
        }

        .tab:hover {
            background-color: #246a99;
        }

        .active-tab {
            background-color: #246a99;
            font-weight: bold;
        }

        /* Initially hide both containers */
        .globe-container, .map-container, .chart-container {
            display: none;
        }

        /* Show active container */
        .active-container {
            display: block;
        }

		/* Then override for bar-container */
		.chart-container.active-container {
			display: flex;
		}

		.map {
			flex: 1;
			height: 100%;
		}

		.globe {
			flex: 1;
			height: 100%;
		}
		
		.chart {
			width: 100%;
		}

		/* Container to align the tables side by side */
		.table-container {
			display: flex;
			justify-content: space-between;
			gap: 20px;
			position: relative;
		}

		/* Table styling */
		table {
			width: 100%;
			margin-top: 20px;
			border-collapse: collapse;
			padding: 10px;
			white-space: nowrap;
		}

		th, td {
			padding: 10px;
			text-align: left;
			border: 1px solid #ddd;
			white-space: nowrap;
		}

		th {
			background-color: #f4f4f4;
		}

		tfoot {
			font-weight: bold;
			background-color: #f9f9f9;
		}

		.faq-item {
			display: block;

			/*width: 38vw;
			min-width: 350px;*/
			margin-top: 0.5rem;
		}
		.item-question {
			background: #143d59;
			color: whitesmoke;
			font-size: 1rem;
			padding: 0.5rem;
			display: flex;
			justify-content: space-between;
			align-items: center;
		}
		.question-text {
			display: inline-block;
		}
		.arrows-container {
			margin: 0.4rem;
		}
		.item-answer {
			display: none;
			color: rgb(0, 0, 0);
			padding: 2rem;
		}
		.close {
			display: none;
		}

		.show-answer .item-answer {
			display: block;
			background: #8dc4ee;
		}
		.show-answer .close {
			display: inline;
		}
		.show-answer .expand {
			display: none;
		}

		/* Style for the arrow button */
		.arrow-button {
			background: #143d59;
			border: none;
			margin: none;
			color: whitesmoke;	
			padding: 10px;		
			font-size: 1rem; /* Increase size for better visibility */
			position: absolute; /* Position relative to the table container */
			top: 96.25px; /* Align with the top of the table */
			left: -42px; /* Place the button outside the table on the right */
			width: 42px;
			height: 42px;
			z-index: 10; /* Ensure the button is above other elements */
		}

		.arrow-button:focus {
			outline: none;
		}
		
		.noUi-horizontal {
			height: 5px;
		}

		.noUi-target {
			border: none;
			background: #e9e9e9;
		}

		.noUi-value {
			margin-top: 8px;
		}

		.noUi-tooltip {
			padding: 0px;
			border: 0px;
		}

		.noUi-connect {
			background: #588db1;;
		}

		.noUi-handle {
			background: #143d59;
			box-shadow: none;
			border: 0px;
			border-radius: 50%; 
		}

		.noUi-handle:before,
		.noUi-handle:after {
			display: none;
		}

		.noUi-pips-horizontal {
			padding: 3px;
		}

		.noUi-horizontal .noUi-handle{
			width: 20px;
			height: 20px;
			color: #000000;
			right: -10px;
			top: -7px;
		}

		.noUi-pips-horizontal{
			height: 10px;
		}

	</style>

		<div class="entry">
			<!-- Preamble to setup the content -->
			Welcome to our tracker for objects re-entering the atmosphere since the start of the megaconstellation era. Select a time window of interest to visualise the location and ID of each re-entry for the time windows, mission type, and object categories selected. Bars total the corresponding emissions and intact (unablated) mass. For more information, see the <a href="#faqs-container">FAQs</a>  at the bottom of this page.<br/> 
			<br>

			Please select a date during 2020-2024. Large ranges may be slow to load.
			<br>
			<br>
			<div class="filter-container">
				<div id="slider" style="width: 400px; margin-right:20px;"></div>
				<div class="filter">
					<label>Re-entry Point</label>
					<div class="dropdown" id="locationFilter">
						<ul></ul>
					</div>
				</div>
			
				<div class="filter">
					<label>Object Type</label>
					<div class="dropdown" id="categoryFilter">
						<ul></ul>
					</div>
				</div>
			
				<div class="filter">
					<label>Megaconstellation?</label>
					<div class="dropdown" id="smcFilter">
						<ul></ul>
					</div>
				</div>

			</div>
			<br>

			<!-- Tabs for globe and map -->
			<div class="tabs">
				<div class="tab" id="chart-tab" onClick="toggleContainer('chart')">Chart</div>
				<div class="tab" id="globe-tab" onClick="toggleContainer('globe')">Globe</div>
				<div class="tab" id="map-tab"   onClick="toggleContainer('map')">Map</div>
				<button class="tab" type="submit" id="applyFilters">Apply Filters</button>
			</div>

			<div id="globe-container" class="globe-container"> <!-- Globe container -->
				<div id="globe" class="globe"></div> 
			</div>
			
			<div id="map-container" class="map-container"> <!-- Map container -->
				<div id="map" class="map"></div> 
			</div>

			<div id="chart-container" class="chart-container"> <!-- Chart container -->
				<div id="stack" class="chart"></div> <!-- Stack container -->
				<div id="bar"   class="chart"></div> <!-- Bar container -->
			</div>

			<!-- Table for Re-entry Locations -->
			<div class="table-container">
				<div>
					<h3>Re-entry Details (Click arrow to expand) </h3>
					<p>[Emissions in tonnes, time in UTC. SMC=Satellite Megaconstellation, Cat=Category, P=Payload, C=Component, B=Booster, S=Stage.]</p>
					
					<table id="reentryTable">
							<thead>
								<tr>
									<th>Date</th>
									<th>ID</th>
									<th>Time</th>
									<th>Location</th>
									<th>Name</th>
									<th>Cat</th>
									<th>SMC</th>
									<th>Al<sub>2</sub>O<sub>3</sub></th>
									<th>NO<sub>x</sub></th>
									<th>BC</th>
									<th>HCl</th>
									<th>Cl</th>
									<th>Unablated Mass</th>
								</tr>
							</thead>
							<tbody id="reentryTableBody" style="display: none;">
								<!-- Dynamic rows for re-entry locations will be inserted here -->
							</tbody>
							<tfoot id="reentryTableFoot">
								<!-- Totals for launches -->
							</tfoot>
							<button id="toggleTableButton" class="arrow-button">&#9650;</button> <!-- Toggle button -->	
						</table>
						
					</div>
			</div>

		<script>

			const startYear = 2020;
			const endYear = 2024;
			const totalMonths = (endYear - startYear + 1) * 12;
			let globe;
			let groupNames = ["Known (Falcon)", "Known (non-Falcon)", "Approximate"];

			function indexToDate(index) {
				const year = startYear + Math.floor(index / 12);
				const intIndex = Math.floor(Number(index)); 
				const month = intIndex % 12;
				return `01/${String(month + 1).padStart(2, '0')}/${year}`;
			}

			function intToDateString(monthIndex) {

				// Calculate year and month offset
				const year = 2020 + Math.floor(monthIndex / 12);
				const month = (monthIndex % 12);

				// Build date object (day 1 of the month)
				const date = new Date(year, month, 1);

				// Format YYYY-MM-DD
				const yyyy = date.getFullYear();
				const mm = String(date.getMonth() + 1).padStart(2, '0'); // month is 0-based
				const dd = String(date.getDate()).padStart(2, '0');

				return `${yyyy}-${mm}-${dd}`;
			}

			noUiSlider.create(slider, {
				start: [48, 60],
				connect: true,
				step: 1,
				range: {
					min: 0,
					max: totalMonths,
				},
				tooltips: [        
					{
						to: value => indexToDate(value),
						from: () => 0
					},
					{
						to: value => indexToDate(value),
						from: () => 0
					}
				],
				format: {
					to: value => Math.round(value),
					from: value => Number(value)
				},
				pips: {
					mode: 'steps',
					density: 12,
					filter: function(value) {
						// Show label only every 12 months (1 year)
						return (value % 12 === 0) ? 1 : 0;  // 1 = show label, 0 = hide
					},
					format: {
						to: function(value) {
							// label only for year start (Jan)
							return value % 12 === 0 ? (startYear + value / 12) : '';
						}
					}
				}
			});	
			
			slider.noUiSlider.on('end', (values, handle) => {
				// values is an array of current slider values as strings
				// handle is 0 (left handle) or 1 (right handle)

				startDate = intToDateString(Number(values[0]));
				endDate = intToDateString(Number(values[1]));
				console.log(startDate, endDate);
				fetchEventsData(); // Fetch data 

				// Now update your data or UI based on leftValue and rightValue
				//updateMyData(leftValue, rightValue);
			});

			const locationGroups = {
						"Known (Falcon)": [5],
						"Known (non-Falcon)": [1,2,3,4], 
						"Approximate": [6,7]
					};


			function populateFilters(reentries) {
				// Get unique values from filtered_reentries for each filter
				const categories = [...new Set(reentries.flatMap(group => group.category))].sort();
				const smcValues = [...new Set(reentries.flatMap(group => group.smc))];

				// Function to populate checkboxes inside a given filter dropdown
				function populateCheckboxes(filterId, values) {
					const dropdown = document.getElementById(filterId);
					const ul = dropdown.querySelector('ul');
					ul.innerHTML = ''; // Clear any previous entries

					values.forEach(value => {
						const li = document.createElement('li');
						li.innerHTML = `<label><input type="checkbox" value="${value}" /> ${value}</label>`;
						ul.appendChild(li);
					});
				}

				// Populate each filter
				populateCheckboxes('locationFilter', groupNames);
				populateCheckboxes('categoryFilter', categories);
				populateCheckboxes('smcFilter', smcValues);
			}

			function filterreentries(all_reentries) {

				function getSelectedfilters(filter) {
					const var_filter = document.getElementById(filter);
					const checkboxes = var_filter.querySelectorAll('input[type="checkbox"]:checked');
					return Array.from(checkboxes).map(checkbox => checkbox.value);
				}

				// Get selected values from each filter
				const selectedReusabilities = getSelectedfilters('locationFilter');
				const selectedCategories    = getSelectedfilters('categoryFilter');
				const selectedSmc           = getSelectedfilters('smcFilter');

				
				// Create an empty array to store the filtered results, maintaining group structure
				let filteredData = all_reentries.map((group, groupIndex) => {
					// Check if the entire group should be excluded
					const groupName = groupNames[groupIndex];
					if (selectedReusabilities.length > 0 && !selectedReusabilities.includes(groupName)) {
						return null; // Exclude this group
					}

					// Get all indices initially
					let indicesToKeep = [...Array(group.date.length).keys()];

					// Filter by category
					if (selectedCategories.length > 0) {
						indicesToKeep = indicesToKeep.filter(i => selectedCategories.includes(group.category[i]));
					}

					// Filter by SMC
					if (selectedSmc.length > 0) {
						indicesToKeep = indicesToKeep.filter(i => selectedSmc.includes(group.smc[i]));
					}

					// Return the filtered group (keeping the structure)
					return {
						date: indicesToKeep.map(i => group.date[i]),
						id: indicesToKeep.map(i => group.id[i]),
						time: indicesToKeep.map(i => group.time[i]),
						smc: indicesToKeep.map(i => group.smc[i]),
						lat: indicesToKeep.map(i => group.lat[i]),
						lon: indicesToKeep.map(i => group.lon[i]),
						category: indicesToKeep.map(i => group.category[i]),
						name: indicesToKeep.map(i => group.name[i]),
						objname: indicesToKeep.map(i => group.objname[i]),
						al: indicesToKeep.map(i => group.al[i]),
						nox: indicesToKeep.map(i => group.nox[i]),
						bc: indicesToKeep.map(i => group.bc[i]),
						hcl: indicesToKeep.map(i => group.hcl[i]),
						cl: indicesToKeep.map(i => group.cl[i]),
						unab_mass: indicesToKeep.map(i => group.unab_mass[i])
					};
				});

				// Remove null entries (groups that were excluded by the filter)
				filteredData = filteredData.filter(group => group !== null);

				// Update the visualizations with the filtered data
				updateVisualizations(filteredData);
			}

			function toggleContainer(containerType) {
				// Reset classes for all tabs and containers
				document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active-tab'));
				document.querySelectorAll('.globe-container, .map-container, .chart-container').forEach(container => container.classList.remove('active-container'));

				// Add active class to the clicked tab
				if (containerType === 'globe') {
					document.getElementById('globe-tab').classList.add('active-tab');
					document.getElementById('globe-container').classList.add('active-container');
					resizeGlobe();
				} else if (containerType === 'map') {
					document.getElementById('map-tab').classList.add('active-tab');
					document.getElementById('map-container').classList.add('active-container');
					Plotly.Plots.resize(document.getElementById('map'));
				} else if (containerType === 'chart') {
					document.getElementById('chart-tab').classList.add('active-tab');
					document.getElementById('chart-container').classList.add('active-container');
				}
			}				

				async function fetchEventsData() {
					try {
						// Fetch the data from the API (replace with your actual API URL)
						const response = await fetch(`https://cbarker.pythonanywhere.com/api/reentries?start_date=${startDate}&end_date=${endDate}`); // Replace with your actual API URL
						const reentryData = await response.json();
						const reentriesByCategory = {};
						
						// Helper function to assign colors based on the location category
						function getColorForCategory(cat) {
							switch (cat) {
								case 'Known (Falcon)':
									return 'green';
								case 'Known (non-Falcon)':
									return 'blue';
								case 'Approximate':
									return 'red';
								default:
									return 'gray'; // Default color for unknown categories
							}
						}

						function getLocationGroup(locationNumber) {
							for (const [groupName, locations] of Object.entries(locationGroups)) {
								if (locations.includes(locationNumber)) {
									return groupName; // Return the group name if the location is found
								}
							}
							return "Unknown Location"; // Fallback for ungrouped locations
						}

						function createReentryCategory(categoryName) {
							return {
								date: [],
								id: [],
								time: [],
								name: [],
								objname: [],
								lat: [],
								lon: [],
								smc: [],
								category: [],
								color: getColorForCategory(categoryName),
								al: [],
								nox: [],
								bc: [],
								hcl: [],
								cl: [],
								unab_mass: []
							};
						}

						reentriesByCategory['Known (Falcon)'] = createReentryCategory('Known (Falcon)');
						reentriesByCategory['Known (non-Falcon)'] = createReentryCategory('Known (non-Falcon)');
						reentriesByCategory['Approximate'] = createReentryCategory('Approximate');

						Object.keys(reentryData).forEach(date => {
							reentryData[date].reentries.forEach(reentry => {
								
								const locationGroup = getLocationGroup(reentry.location);
								
								// Add reentry data to the category group
								reentriesByCategory[locationGroup].date.push(reentry.date);
								reentriesByCategory[locationGroup].id.push(reentry.id);
								reentriesByCategory[locationGroup].time.push(reentry.time);
								reentriesByCategory[locationGroup].smc.push(reentry.smc ? "Yes" : "No");
								reentriesByCategory[locationGroup].lat.push(reentry.lat);
								reentriesByCategory[locationGroup].name.push(locationGroup);
								reentriesByCategory[locationGroup].category.push(reentry.category);
								reentriesByCategory[locationGroup].lon.push(reentry.lon);
								reentriesByCategory[locationGroup].objname.push(reentry.name);
								reentriesByCategory[locationGroup].al.push(reentry.emissions.Al2O3);
								reentriesByCategory[locationGroup].nox.push(reentry.emissions.NOx);
								reentriesByCategory[locationGroup].bc.push(reentry.emissions.BC);
								reentriesByCategory[locationGroup].hcl.push(reentry.emissions.HCl);
								reentriesByCategory[locationGroup].cl.push(reentry.emissions.Cl);
								reentriesByCategory[locationGroup].unab_mass.push(reentry.emissions.Unablated_Mass);
							});
						});

						// Combine the arrays into the desired structure and update the visualisations.
						all_reentries = Object.values(reentriesByCategory);

						populateFilters(all_reentries);
						updateVisualizations(all_reentries);

					} catch (error) {
						console.error('Error fetching or processing the events data:', error);
					}
				}

				function updateVisualizations(filtered_reentries) {
					updateTables(filtered_reentries);
					updateMaps(filtered_reentries);
					updateGraph(filtered_reentries);
					updateGlobe(filtered_reentries);
					updateStack(filtered_reentries);
				}

				function updateGlobe(filtered_reentries) {

					const allGData = [];

					filtered_reentries.forEach(locationSet => {
						const gData = locationSet.lat.map((latitude, index) => {
							const longitude = locationSet.lon[index];
	
							return {
								lat: latitude,
								lon: longitude,
								name: `Re-entry ID ${locationSet.id[index]}`,
							};
						});

						allGData.push(...gData);
					});

					const OPACITYPATH  = 0.3;
					
					if (!globe) {
						globe = new Globe(document.getElementById('globe'))
							.globeImageUrl('https://cdn.jsdelivr.net/npm/three-globe/example/img/earth-blue-marble.jpg')
							.pointLat(d => d.lat)
							.pointLng(d => d.lon)
							.pointColor(() => `rgba(255, 0, 0, ${OPACITYPATH})`)
							.pointRadius(0.5)
							.pointAltitude(0.2)
							.onPointHover(hoverPoint => {
								globe
								.pointColor(d => {
									const op = !hoverPoint ? OPACITYPATH : d === hoverPoint ? 0.9 : 0;
									return `rgba(255, 0, 0, ${op})`;
								})
								.labelSize(d => {
									// Show label only if this label matches the hovered point
									return hoverPoint && d.name === hoverPoint.name ? 1.5 : 0;
								});
							});
						
						globe.pointsData(allGData);

						setTimeout(() => {
						globe
							.pointOfView({ lat: 0, lng: 0, altitude: 1.9 }, 1000);
						}, 0);

					} else {
						globe.pointsData(allGData);
					}
				}

				function updateTables(filtered_reentries) {
					
					// Flatten all groups into a single array of rows (with date sorting)
					let allRows = [];
					filtered_reentries.forEach(group => {
						group.id.forEach((location, index) => {
							const row = {
								date: group.date[index],
								location: location,
								time: group.time[index],
								name: group.name[index],
								objname: group.objname[index],
								category: group.category[index],
								smc: group.smc[index],
								al: group.al[index],
								nox: group.nox[index],
								bc: group.bc[index],
								hcl: group.hcl[index],
								cl: group.cl[index],
								unab_mass: group.unab_mass[index],
								groupName: group.name[index] // Keep track of the group name for later
							};
							allRows.push(row);
						});
					});

					// Sort rows by date
					allRows.sort((a, b) => new Date(a.date) - new Date(b.date));  // Ensure date is sorted from earliest to latest

					// Populate Re-entry Table
					const table2Body = document.getElementById('reentryTableBody');
					const table2Foot = document.getElementById('reentryTableFoot');
					table2Body.innerHTML = '';
					table2Foot.innerHTML = '';
					let totalal = 0, totalnox = 0, totalmass = 0;
					let totalbc = 0, totalhcl = 0, totalcl = 0;

					allRows.forEach(row => {
						const { date, location, time, name, objname, category, smc, al, nox, bc, hcl, cl, unab_mass } = row;

						const tableRow = document.createElement('tr');
						totalal += al;
						totalnox += nox;
						totalbc += bc;
						totalhcl += hcl;
						totalcl += cl;
						totalmass += unab_mass;
						tableRow.innerHTML = `
							<td>${date}</td>
							<td>${location}</td> 
							<td>${time.toFixed(2)}</td>
							<td class="wrap-text">${name}</td>
							<td class="wrap-text">${objname}</td>
							<td>${category}</td>
							<td>${smc}</td>
							<td>${al.toFixed(2)}</td>
							<td>${nox.toFixed(2)}</td>
							<td>${bc.toFixed(2)}</td>
							<td>${hcl.toFixed(2)}</td>
							<td>${cl.toFixed(2)}</td>
							<td>${unab_mass.toFixed(2)}</td>
							`;
						table2Body.appendChild(tableRow);
					});

					// Add Totals to Re-entry Table
					const totalRow2 = document.createElement('tr');
					totalRow2.innerHTML = `
						<td>Total</td>
						<td>-</td>
						<td>-</td>
						<td>-</td>
						<td>-</td>
						<td>-</td>
						<td>-</td>
						<td>${totalal.toFixed(2)}</td>
						<td>${totalnox.toFixed(2)}</td>
						<td>${totalbc.toFixed(2)}</td>
						<td>${totalhcl.toFixed(2)}</td>
						<td>${totalcl.toFixed(2)}</td>
						<td>${totalmass.toFixed(2)}</td>
					`;
					table2Foot.appendChild(totalRow2);
				}
				
				function updateMaps(filtered_reentries) {
					// Prepare the data for Plotly
					
					let plotlyData = [];
					Object.keys(filtered_reentries).forEach(locationGroup => {
						const groupData = filtered_reentries[locationGroup];
						plotlyData.push({
							type: 'scattergeo',
							mode: 'markers',
							name: groupNames[locationGroup],
							lat: groupData.lat,
							lon: groupData.lon,
							marker: {
								size: 12,
								color: groupData.color,
								symbol: 'x'
							},
							
							showlegend: true
						});
					});

					// Common layout configuration
					const layout = {
						geo: {
							resolution: 100, 
							projection: { type: 'robinson' },
							showland: true,
							landcolor: 'rgb(217, 217, 217)',
							showocean: true,
							oceancolor: 'rgb(204, 233, 255)',
							showcountries: true,
							countrycolor: 'rgb(50, 50, 50)',
							showsubunits: true,
							subunitcolor: 'rgb(150, 150, 150)',
							showgrid: true,
							gridcolor: 'rgb(220, 220, 220)',
							gridwidth: 2,
							griddash: 'dash', // Dashed gridlines for both axes
							lataxis: {
								showgrid: true,  // Gridline for latitude axis
								gridcolor: 'rgb(220, 220, 220)', // Optional: specify grid color
								griddash: 'dash', // Dashed gridline style
								tickmode: 'array',
								ticks: '',
								ticklen: 10,
								tickcolor: 'rgb(220, 220, 220)',
								showticklabels: false,
								zeroline: false
							},
							lonaxis: {
								showgrid: true,  // Gridline for longitude axis
								gridcolor: 'rgb(220, 220, 220)', // Optional: specify grid color
								griddash: 'dash', // Dashed gridline style
								tickmode: 'array',
								ticks: '',
								ticklen: 10,
								tickcolor: 'rgb(220, 220, 220)',
								showticklabels: false,
								zeroline: false
							}
						},
						autosize: true,  // Automatically resize the chart
						margin: {
							l: 40,
							r: 40,
							t: 40,
							b: 40  // <- reduce bottom margin here
						},
						showlegend: true,
						legend: {
							x: 0.5,
							y: -0.05,
							xanchor: 'center',
							orientation: 'h',
							traceorder: 'normal',
							font: { size: 14 },
							bgcolor: 'rgba(255, 255, 255, 0.5)',  // Slight transparent background
						},
					};
					
					Plotly.newPlot('map', plotlyData, layout, {responsive: true});
				}

				const prettyNames = {
					al: 'Al<sub>2</sub>O<sub>3</sub>',
					nox: 'NO<sub>x</sub>',
					unab_mass: 'Unablated Mass',
					bc: 'BC',
					hcl: 'HCl',
					cl: 'Cl',
					
				};
				
				function updateGraph(filtered_reentries) {

					const totals = {
						al: 0,
						nox: 0,
						unab_mass: 0,
						bc: 0,
						hcl: 0,
						cl: 0
					};

					filtered_reentries.forEach(group => {
						group.id.forEach((location, index) => {
							totals.al        += group.al[index];
							totals.nox       += group.nox[index];
							totals.unab_mass += group.unab_mass[index];
							totals.bc        += group.bc[index];
							totals.hcl       += group.hcl[index];
							totals.cl        += group.cl[index];
						});
					});
					
					// Prepare the data for Plotly
					const maxYValue = Object.values(totals).reduce((sum, val) => sum + val, 0);

					const trace = Object.keys(totals).map(key => ({
						x: ['Total'],
						y: [totals[key]],
						name: prettyNames[key],
						type: 'bar',
					}));

					const layout = {
						title: {
							text: 'Total Emissions',
						},
						barmode: 'stack',
						yaxis: {
							range: [0,maxYValue]
						},
						legend: {
							orientation: 'v',
							x: 1.05,
							y: 1,
							itemwidth: 3,
						},
						autosize: true,  // Automatically resize the chart
						margin: {
							l: 40,
							r: 140,
							t: 40,
							b: 0  // <- reduce bottom margin here
						}
					};

					// Plot the chart inside the 'emissionsChart' div
					Plotly.newPlot('bar', trace, layout, {responsive: true});

				}

				function updateStack(filtered_reentries) {

					const species = ['al', 'nox', 'unab_mass', 'bc', 'hcl', 'cl'];
					const monthlySums = {};

					// Step 1: Loop through each launch (index)
					filtered_reentries.forEach(reentryGroup => {
						for (let i = 0; i < reentryGroup.date.length; i++) {
							const month = reentryGroup.date[i].slice(0, 7);  // 'YYYY-MM'
							
							if (!monthlySums[month]) {
								monthlySums[month] = {};
								species.forEach(sp => monthlySums[month][sp] = 0);
							}
							
							species.forEach(sp => {
								monthlySums[month][sp] += Number(reentryGroup[sp][i]) || 0; // Ensure numeric
							});
						}
					});

					const months = Object.keys(monthlySums).sort();
					const maxYValue = Math.max(...months.map(month =>	species.reduce((sum, sp) => sum + monthlySums[month][sp], 0)));

					const traces = species.map(sp => ({
						x: months,
						y: months.map(m => monthlySums[m][sp]),
						stackgroup: 'one',
						name: prettyNames[sp],
						type: 'scatter',
						mode: 'none',
					}));

					const layout = {
						autosize: true,
						title: {
							text: 'Monthly Emissions (click legend to show/hide species)',
						},
						font: {
							size: 12        // x-axis font size
						},
						yaxis: {
							title: {
								text: 'Mass [t]',
							},
							range: [0,maxYValue]
						},
						legend: {
							orientation: 'v',
							x: 1.05,
							y: 1,
						},
						autosize: true,  // Automatically resize the chart
						margin: {
							l: 80,
							r: 40,
							t: 40,
							b: 0  // <- reduce bottom margin here
						}
					};

					Plotly.newPlot('stack', traces , layout, {responsive: true});

				}
				
				// Plot a default date when the page opens, then update when the date changes.
				document.addEventListener('DOMContentLoaded', () => {

					const daterange = slider.noUiSlider.get();
					startDate = intToDateString(Number(daterange[0]));
					endDate = intToDateString(Number(daterange[1]));
					fetchEventsData(); // Fetch data for the default date

					document.getElementById('applyFilters').addEventListener('click', () => {
						filterreentries(all_reentries);
					});
				});
				
				// JavaScript to toggle the table visibility and update the arrow
				const toggleButton = document.getElementById('toggleTableButton');
				const tableBody = document.getElementById('reentryTableBody');

				// Initialize with the globe container active
				toggleContainer('chart');

				toggleButton.addEventListener('click', () => {
					const isHidden = tableBody.style.display === 'none';
					tableBody.style.display = isHidden ? 'table-row-group' : 'none';
					toggleButton.innerHTML = isHidden ? '&#9660;' : '&#9650;'; // Down arrow when shown, up arrow when hidden
				});

				document.querySelectorAll('.filter').forEach(filter => {
				filter.addEventListener('click', e => {
					// Prevent toggling when clicking inside dropdown list itself
					if (e.target.closest('.dropdown ul')) return;

					// Close other open dropdowns first (optional)
					document.querySelectorAll('.filter.open').forEach(openFilter => {
					if (openFilter !== filter) openFilter.classList.remove('open');
					});

					// Toggle current filter open class
					filter.classList.toggle('open');
				});
			});

			// Optional: Close dropdowns if clicked outside
			document.addEventListener('click', e => {
				if (!e.target.closest('.filter')) {
					document.querySelectorAll('.filter.open').forEach(openFilter => {
					openFilter.classList.remove('open');
					});
				}
			});

			// Function to resize the globe based on its container size
			const resizeGlobe = () => {
				const container = document.getElementById('globe');
				// Set the width and height of the globe based on the container's size
				globe.width(container.offsetWidth).height(container.offsetHeight);
				
				// Manually reset the canvas element size to match the container size
				const canvas = document.querySelector('canvas');
				canvas.style.width = `${container.offsetWidth}px`;
				canvas.style.height = `${container.offsetHeight}px`;
				canvas.style.transform = 'none';
			};

		</script> 
			<br>
			<a href="#">Go to Top</a>
			<br>
			<br>
			<h2>Frequently Asked Questions</h2>

			<div id="faqs-container"></div>

			<script>
				const faqData = [ 
					{ question: "What are these chemicals?",
					answer: "NO<sub>x</sub> is nitrogen oxides, BC is black carbon or soot, Al<sub>2</sub>O<sub>3</sub> is aluminium oxide or alumina, and Cl<sub>y</sub> is a family of chlorine compounds. NO<sub>x</sub> and Cl<sub>y</sub> are released as gases, BC and Al<sub>2</sub>O<sub>3</sub> as particles."
					},
					{ question: "How do these chemicals affect the atmosphere?",
						answer: "Re-entries release air pollutant emissions into the upper layers of the atmosphere, where they can have an outsized impact on our atmosphere and climate. NO<sub>x</sub> and Cl<sub>y</sub> are the largest contributors to destruction of the ozone layer from rocket emissions, with smaller destruction occuring from emissions of BC and Al<sub>2</sub>O<sub>3</sub> particles. The largest climate impacts come from BC emissions, which warm the upper layers of the atmosphere while cooling the lower layers."
						},
					{ question: "What does each filter represent?",
						answer: "Re-entry point allows users to filter for re-entering objects that are known and that we have had to approximate, as exact location data is not available. Known re-entries are further separated into Falcon and non-Falcon rocket and fairing re-entries.  Object Type distinguishes individual re-entering objects as Payload (P), C=Component (C1), Booster (B1-B4), and rocket stage (S1-S4). Megaconstellation allows users to select re-entries that are or are not associated with megaconstellation missions."
						},					
					{ question: "How is this data calculated?",
					answer: "Our calculations are based on the current best scientific knowledge available for emissions from object re-entries. We use object-specific ablation profiles to calculate alumina emissions from object re-entries, including all objects with an apogee above 50 km. Paths shown in the Globe view are fixed at the re-entry location and do not represent real object trajectories."
					},
					{ question: "Where can I find the original methodology and data?",
					answer: "You can find further details in our study published in Nature Scientific Data: Global 3D rocket launch and re-entry air pollutant and carbon dioxide emissions for 2020-2022</strong>. C. R. Barker, E. A. Marais (2024). doi:10.5522/04/26325382. [<a href='https://doi.org/10.5522/04/26325382' target='_blank' rel='noopener noreferrer'>Data</a>]. [<a href='https://www.nature.com/articles/s41597-024-03910-z' target='_blank' rel='noopener noreferrer'>Publication</a>]</p>"
					}
				];

				const faqsContainer = document.getElementById('faqs-container');

				faqData.map(function(item) {

					let article = document.createElement('article');
					article.classList.add('faq-item');

					const markup = `
							<div class="item-question">
								<span class="question-text">${item.question}</span>
								<span class="arrows-container">
									<span class="expand">▼</span>
									<span class="close">▲</span>
								</span>
							</div>
							<div class="item-answer">
								<span>${item.answer}</span>
							</div>
					`;
					
					article.innerHTML = markup;
					faqsContainer.append(article);
				});

				const toggleButtons = document.querySelectorAll('.arrows-container');
					
				toggleButtons.forEach(button => {
					button.addEventListener('click', function(e) {
						const faqItem = e.currentTarget.parentElement.parentElement;
						faqItem.classList.toggle("show-answer");
					});
				});

			</script>

			<p>
				Developed by <a href="https://profiles.ucl.ac.uk/93616-connor-barker" target="_blank" rel="noopener noreferrer">Connor Barker</a> (UCL postdoc) and <a href="https://profiles.ucl.ac.uk/77783-eloise-marais" target="_blank" rel="noopener noreferrer">Eloise Marais</a> (UCL PI), in collaboration with <a href="https://www.cfa.harvard.edu/people/jonathan-mcdowell" target="_blank" rel="noopener noreferrer">Jonathan McDowell</a> (Harvard-Smithsonian Center for Astrophysics) and Eric Tan (UCL Department of Astrophysics). Interested in using the data or spot any room for improvements? Please reach out to Connor Barker at <a href= "mailto:name@email.com">connor.barker@ucl.ac.uk</a>.
			</p>
			<p>
				<strong>Funding Disclaimer:</strong> This project has received funding from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement No. 851854). <a href="https://cordis.europa.eu/project/id/851854" target="_blank" rel="noopener noreferrer">European Commission project page</a>.
			</p>
		</div>
		</div>
	</div>
</div>

<hr />
<div id="footer">
	<p>
		<br> <br />
	</p>
</div>
<script type="text/javascript' src='./js/wp-embed.min.js"></script>
</body>
</html>