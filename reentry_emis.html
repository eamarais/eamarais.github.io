<!doctype html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Object Re-entry Emissions</title>

	<link rel="stylesheet" href="style.css" type="text/css" media="screen" />
	<style>
		#page { background: url("./themes/default/images/kubrickbgwide.jpg") repeat-y top; border: none; }
	</style>

	<!-- Plotly & Globe -->
	<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/globe.gl"></script>

	<!-- Google tag (gtag.js) -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-L03HTPL2E2"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());
		gtag('config', 'G-L03HTPL2E2');
	</script>

</head>

<body>

<div id="page">
	
<div id="header">

	<!--Header image-->
	<div id="headerimg">
		<h1>
			<a style="color:black" href="http://maraisresearchgroup.co.uk/">
				<div class="transparent-box">Atmospheric Composition and Air Quality Group</div>
			</a>
		</h1>
		<div class="description"></div>
	</div>

<!--Navigation bar-->
	<div id="navmenu">
		<iframe src="./nav.html" onload="this.before((this.contentDocument.body||this.contentDocument).children[0]);this.remove()"></iframe>
	</div>

</div>

<hr />

<div id="content" class="widecolumn">

	<div class="post" id="post-3">
		<h2 style="text-transform: none;
				   margin-top: 20px;
				   margin-bottom: 20px;
				   font-size: 3.2em;
				   font-weight: 500;
				   line-height: 1.2em;">
            Emissions from Artificial Object Re-entries
</h2>
				<div class="entry">	
				
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
					
	<style>

		.filter-container {
			display: flex;
			justify-content: space-around;
			align-items: center;
			padding: 10px;
			list-style-type: circle;
		}

		.filter {
			position: relative;
			background: #143d59;
			color: whitesmoke;
			font-size: 1rem;
			padding: 0.5rem;
			height: 15px;
			border-radius: 5px;
		}

		/* Bold label */
		.filter label {
			font-size: 16px; /* Adjust size if needed */
		}

		/* Hide dropdown initially */
		.dropdown ul {
			display: none;
			position: absolute;
			left:50%;
			transform: translateX(-50%);
			list-style-type: none;
			background-color: #8dc4ee;
			max-height: 300px;
			overflow-y: auto;
			width: auto;
			min-width: 150px; /* Ensure a minimum width */
			white-space: nowrap;
			border-radius: 5px;
			z-index: 100;
			top: 15px;
		}

		/* Show dropdown when hovering */
		.filter:hover .dropdown ul {
			text-align: left;
			display: inline-block;
		}

		.dropdown li:hover {
			background-color: #143d59;
			list-style-type: none;
		}

		.dropdown label {
			font-size: 14px; /* Smaller font size */
			font-weight: normal !important; /* Prevent bold */
			display: flex;
			align-items: center;
			gap: 15px; /* Space between checkbox and text */
			padding: 0px 10px; /* Add padding (top-bottom, left-right) */
		}

		.wrap-text {
			white-space: normal;
			word-wrap: break-word;
			max-width: 500px; /* Adjust the width as needed */
		}
		
		/* Container to align the maps side by side */
		.map-container {
			display: flex;
			justify-content: space-between;
			gap: 20px;
			padding: 20px;
						/* Ensure container size is constrained */
			width: 100%; /* or set a specific width like 80% if desired */
			height: 100%; /* You can adjust this as needed */
			box-sizing: border-box; /* Ensure padding is included in the container size */
		}

		/* Prevent flex items from stretching */
		.globe-container {
			flex-shrink: 0;
			flex-grow: 0;
			width: 100%; /* Ensure it fills the available space */
			height: 100%; /* Ensure it fills the available height */
		}
		
		/* Prevent flex items from stretching */
		.bar-container {
			width: 100%; /* Ensure it fills the available space */
			height: 100%; /* Ensure it fills the available height */
		}

        /* Style for the tabs */
        .tabs {
            display: flex;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .tab {
            padding: 10px 20px;
            margin-right: 10px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        .tab:hover {
            background-color: #ddd;
        }

        .active-tab {
            background-color: #ccc;
            font-weight: bold;
        }

        /* Initially hide both containers */
        .globe-container, .map-container, .bar-container {
            display: none;
        }

        /* Show active container */
        .active-container {
            display: block;
        }

		.map {
			flex: 1;
			height: 100%;
		}

		.globe {
			flex: 1;
			height: 100%;
		}
		
		.bar {
			width: 100%;
		}

		/* Container to align the tables side by side */
		.table-container {
			display: flex;
			justify-content: space-between;
			gap: 20px;
			position: relative;
		}

		/* Table styling */
		table {
			width: 100%;
			margin-top: 20px;
			border-collapse: collapse;
			padding: 10px;
			white-space: nowrap;
		}

		th, td {
			padding: 10px;
			text-align: left;
			border: 1px solid #ddd;
			white-space: nowrap;
		}

		th {
			background-color: #f4f4f4;
		}

		tfoot {
			font-weight: bold;
			background-color: #f9f9f9;
		}

		.faq-item {
			display: block;

			/*width: 38vw;
			min-width: 350px;*/
			margin-top: 0.5rem;
		}
		.item-question {
			background: #143d59;
			color: whitesmoke;
			font-size: 1rem;
			padding: 0.5rem;
			display: flex;
			justify-content: space-between;
			align-items: center;
		}
		.question-text {
			display: inline-block;
		}
		.arrows-container {
			margin: 0.4rem;
		}
		.item-answer {
			display: none;
			color: rgb(0, 0, 0);
			padding: 2rem;
		}
		.close {
			display: none;
		}

		.show-answer .item-answer {
			display: block;
			background: #8dc4ee;
		}
		.show-answer .close {
			display: inline;
		}
		.show-answer .expand {
			display: none;
		}

		/* Style for the arrow button */
		.arrow-button {
			background: #143d59;
			border: none;
			margin: none;
			color: whitesmoke;	
			padding: 10px;		
			font-size: 1rem; /* Increase size for better visibility */
			position: absolute; /* Position relative to the table container */
			top: 96.25px; /* Align with the top of the table */
			left: -42px; /* Place the button outside the table on the right */
			width: 42px;
			height: 42px;
			z-index: 10; /* Ensure the button is above other elements */
		}

		.arrow-button:focus {
			outline: none;
		}
		
	</style>

		<div class="entry">
			<!-- Preamble to setup the content -->
			Welcome to our tracker for objects re-entering the atmosphere since the start of the megaconstellation era. Select a time window of interest to visualise the location and ID of each re-entry for the time windows, mission type, and object categories selected. Bars total the corresponding emissions and intact (unablated) mass. For more information, see the <a href="#faqs-container">FAQs</a>  at the bottom of this page.<br/> 
			<br>

			Please select a date during 2020-2024. Large ranges may be slow to load.
			<br>
			<br>
			<label>Start Date: <input type="date" id="datePicker1" name="datePicker1"></label>
			<label>End Date: <input type="date" id="datePicker2" name="datePicker2"></label>
			<br>

			<div class="filter-container">
				<div class="filter">
					<label>Re-entry Point</label>
					<div class="dropdown" id="locationFilter">
						<ul></ul>
					</div>
				</div>
			
				<div class="filter">
					<label>Object Type</label>
					<div class="dropdown" id="categoryFilter">
						<ul></ul>
					</div>
				</div>
			
				<div class="filter">
					<label>Megaconstellation?</label>
					<div class="dropdown" id="smcFilter">
						<ul></ul>
					</div>
				</div>
				
				<button type="submit" id="applyFilters">Apply Filters</button>

			</div>
			<br>

			<!-- Tabs for globe and map -->
			<div class="tabs">
				<div class="tab" id="globe-tab" onClick="toggleContainer('globe')">Globe</div>
				<div class="tab" id="map-tab" onClick="toggleContainer('map')">Map</div>
				<div class="tab" id="bar-tab" onClick="toggleContainer('bar')">Bar</div>
			</div>

			<div id="globe-container" class="globe-container">
				<div id="globeplot" class="globe"></div> <!-- Globe container -->
			</div>
			
			<div id="map-container" class="map-container">
				<div id="map1" class="map"></div> <!-- Map container -->
			</div>

			<div id="bar-container" class="bar-container">
				<div id="bar1" class="bar"></div> <!-- Bar container -->
			</div>

			<!-- Table for Re-entry Locations -->
			<div class="table-container">
				<div>
					<h3>Re-entry Details (Click arrow to expand) </h3>
					<p>[Emissions in tonnes, time in UTC. SMC=Satellite Megaconstellation, Cat=Category, P=Payload, C=Component, B=Booster, S=Stage.]</p>
					
					<table id="reentryTable">
							<thead>
								<tr>
									<th>Date</th>
									<th>ID</th>
									<th>Time</th>
									<th>Location</th>
									<th>Name</th>
									<th>Cat</th>
									<th>SMC</th>
									<th>Al<sub>2</sub>O<sub>3</sub></th>
									<th>NO<sub>x</sub></th>
									<th>BC</th>
									<th>HCl</th>
									<th>Cl</th>
									<th>Unablated Mass</th>
								</tr>
							</thead>
							<tbody id="reentryTableBody" style="display: none;">
								<!-- Dynamic rows for re-entry locations will be inserted here -->
							</tbody>
							<tfoot id="reentryTableFoot">
								<!-- Totals for launches -->
							</tfoot>
							<button id="toggleTableButton" class="arrow-button">&#9650;</button> <!-- Toggle button -->	
						</table>
						
					</div>
			</div>

			<script>

				// Initialize with the globe container active
				toggleContainer('globe');

			    // Initialize variables 
				let startDate = '2024-01-01';
				let endDate = '2024-01-20';
				let globe;
				let groupNames = ["Known (Falcon)", "Known (non-Falcon)", "Approximate"];

				const locationGroups = {
							"Known (Falcon)": [5],
							"Known (non-Falcon)": [1,2,3,4], 
							"Approximate": [6,7]
						};


				function populateFilters(reentries) {
					// Get unique values from filtered_reentries for each filter
					const categories = [...new Set(reentries.flatMap(group => group.category))].sort();
					const smcValues = [...new Set(reentries.flatMap(group => group.smc))];

					// Function to populate checkboxes inside a given filter dropdown
					function populateCheckboxes(filterId, values) {
						const dropdown = document.getElementById(filterId);
						const ul = dropdown.querySelector('ul');
						ul.innerHTML = ''; // Clear any previous entries

						values.forEach(value => {
							const li = document.createElement('li');
							li.innerHTML = `<label><input type="checkbox" value="${value}" /> ${value}</label>`;
							ul.appendChild(li);
						});
					}

					// Populate each filter
					populateCheckboxes('locationFilter', groupNames);
					populateCheckboxes('categoryFilter', categories);
					populateCheckboxes('smcFilter', smcValues);
				}

				function filterreentries(all_reentries) {

					function getSelectedfilters(filter) {
						const var_filter = document.getElementById(filter);
						const checkboxes = var_filter.querySelectorAll('input[type="checkbox"]:checked');
						return Array.from(checkboxes).map(checkbox => checkbox.value);
					}

					// Get selected values from each filter
					const selectedReusabilities = getSelectedfilters('locationFilter');
					const selectedCategories    = getSelectedfilters('categoryFilter');
					const selectedSmc           = getSelectedfilters('smcFilter');

					
					// Create an empty array to store the filtered results, maintaining group structure
					let filteredData = all_reentries.map((group, groupIndex) => {
						// Check if the entire group should be excluded
						const groupName = groupNames[groupIndex];
						if (selectedReusabilities.length > 0 && !selectedReusabilities.includes(groupName)) {
							return null; // Exclude this group
						}

						// Get all indices initially
						let indicesToKeep = [...Array(group.date.length).keys()];

						// Filter by category
						if (selectedCategories.length > 0) {
							indicesToKeep = indicesToKeep.filter(i => selectedCategories.includes(group.category[i]));
						}

						// Filter by SMC
						if (selectedSmc.length > 0) {
							indicesToKeep = indicesToKeep.filter(i => selectedSmc.includes(group.smc[i]));
						}

						// Return the filtered group (keeping the structure)
						return {
							date: indicesToKeep.map(i => group.date[i]),
							id: indicesToKeep.map(i => group.id[i]),
							time: indicesToKeep.map(i => group.time[i]),
							smc: indicesToKeep.map(i => group.smc[i]),
							lat: indicesToKeep.map(i => group.lat[i]),
							lon: indicesToKeep.map(i => group.lon[i]),
							category: indicesToKeep.map(i => group.category[i]),
							name: indicesToKeep.map(i => group.name[i]),
							objname: indicesToKeep.map(i => group.objname[i]),
							al: indicesToKeep.map(i => group.al[i]),
							nox: indicesToKeep.map(i => group.nox[i]),
							bc: indicesToKeep.map(i => group.bc[i]),
							hcl: indicesToKeep.map(i => group.hcl[i]),
							cl: indicesToKeep.map(i => group.cl[i]),
							unab_mass: indicesToKeep.map(i => group.unab_mass[i])
						};
					});

					// Remove null entries (groups that were excluded by the filter)
					filteredData = filteredData.filter(group => group !== null);

					// Update the visualizations with the filtered data
					updateVisualizations(filteredData);
				}

				function toggleContainer(containerType) {
					// Reset classes for all tabs and containers
					document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active-tab'));
					document.querySelectorAll('.globe-container, .map-container, .bar-container').forEach(container => container.classList.remove('active-container'));

					// Add active class to the clicked tab
					if (containerType === 'globe') {
						document.getElementById('globe-tab').classList.add('active-tab');
						document.getElementById('globe-container').classList.add('active-container');
					} else if (containerType === 'map') {
						document.getElementById('map-tab').classList.add('active-tab');
						document.getElementById('map-container').classList.add('active-container');
					} else if (containerType === 'bar') {
						document.getElementById('bar-tab').classList.add('active-tab');
						document.getElementById('bar-container').classList.add('active-container');
					}
				}				

				async function fetchEventsData() {
					try {
						// Fetch the data from the API (replace with your actual API URL)
						const response = await fetch(`https://cbarker.pythonanywhere.com/api/reentries?start_date=${startDate}&end_date=${endDate}`); // Replace with your actual API URL
						const reentryData = await response.json();
						const reentriesByCategory = {};
						
						// Helper function to assign colors based on the location category
						function getColorForCategory(cat) {
							switch (cat) {
								case 'Known (Falcon)':
									return 'green';
								case 'Known (non-Falcon)':
									return 'blue';
								case 'Approximate':
									return 'red';
								default:
									return 'gray'; // Default color for unknown categories
							}
						}

						function getLocationGroup(locationNumber) {
							for (const [groupName, locations] of Object.entries(locationGroups)) {
								if (locations.includes(locationNumber)) {
									return groupName; // Return the group name if the location is found
								}
							}
							return "Unknown Location"; // Fallback for ungrouped locations
						}

						function createReentryCategory(categoryName) {
							return {
								date: [],
								id: [],
								time: [],
								name: [],
								objname: [],
								lat: [],
								lon: [],
								smc: [],
								category: [],
								color: getColorForCategory(categoryName),
								al: [],
								nox: [],
								bc: [],
								hcl: [],
								cl: [],
								unab_mass: []
							};
						}

						reentriesByCategory['Known (Falcon)'] = createReentryCategory('Known (Falcon)');
						reentriesByCategory['Known (non-Falcon)'] = createReentryCategory('Known (non-Falcon)');
						reentriesByCategory['Approximate'] = createReentryCategory('Approximate');

						Object.keys(reentryData).forEach(date => {
							reentryData[date].reentries.forEach(reentry => {
								
								const locationGroup = getLocationGroup(reentry.location);
								
								// Add reentry data to the category group
								reentriesByCategory[locationGroup].date.push(reentry.date);
								reentriesByCategory[locationGroup].id.push(reentry.id);
								reentriesByCategory[locationGroup].time.push(reentry.time);
								reentriesByCategory[locationGroup].smc.push(reentry.smc ? "Yes" : "No");
								reentriesByCategory[locationGroup].lat.push(reentry.lat);
								reentriesByCategory[locationGroup].name.push(locationGroup);
								reentriesByCategory[locationGroup].category.push(reentry.category);
								reentriesByCategory[locationGroup].lon.push(reentry.lon);
								reentriesByCategory[locationGroup].objname.push(reentry.name);
								reentriesByCategory[locationGroup].al.push(reentry.emissions.Al2O3);
								reentriesByCategory[locationGroup].nox.push(reentry.emissions.NOx);
								reentriesByCategory[locationGroup].bc.push(reentry.emissions.BC);
								reentriesByCategory[locationGroup].hcl.push(reentry.emissions.HCl);
								reentriesByCategory[locationGroup].cl.push(reentry.emissions.Cl);
								reentriesByCategory[locationGroup].unab_mass.push(reentry.emissions.Unablated_Mass);
							});
						});

						// Combine the arrays into the desired structure and update the visualisations.
						all_reentries = Object.values(reentriesByCategory);

						populateFilters(all_reentries);
						updateVisualizations(all_reentries);

					} catch (error) {
						console.error('Error fetching or processing the events data:', error);
					}
				}

				function updateVisualizations(filtered_reentries) {
					updateTables(filtered_reentries);
					updateMaps(filtered_reentries);
					updateGraph(filtered_reentries);
					updateGlobe(filtered_reentries);
				}

				function updateGlobe(filtered_reentries) {

					const allGData = [];

					filtered_reentries.forEach(locationSet => {
						const gData = locationSet.lat.map((latitude, index) => {
							const longitude = locationSet.lon[index];
	
							return {
								lat: latitude,
								lon: longitude,
								name: `Re-entry ID ${locationSet.id[index]}`,
							};
						});

						allGData.push(...gData);
					});

					const OPACITYPATH  = 0.3;
					
					if (!globe) {
						globe = new Globe(document.getElementById('globeplot'))
							.globeImageUrl('https://cdn.jsdelivr.net/npm/three-globe/example/img/earth-blue-marble.jpg')
							.pointLat(d => d.lat)
							.pointLng(d => d.lon)
							.pointColor(() => `rgba(255, 0, 0, ${OPACITYPATH})`)
							.pointRadius(0.5)
							.pointAltitude(0.2)
							.onPointHover(hoverPoint => {
								globe
								.pointColor(d => {
									const op = !hoverPoint ? OPACITYPATH : d === hoverPoint ? 0.9 : 0;
									return `rgba(255, 0, 0, ${op})`;
								})
								.labelSize(d => {
									// Show label only if this label matches the hovered point
									return hoverPoint && d.name === hoverPoint.name ? 1.5 : 0;
								});
							});
						
						globe.pointsData(allGData);

						setTimeout(() => {
						globe
							.pointOfView({ lat: 0, lng: 0, altitude: 1.9 }, 1000);
						}, 0);

					} else {
						globe.pointsData(allGData);
					}

					// Function to resize the globe based on its container size
					const resizeGlobe = () => {
						const container = document.getElementById('globeplot');
						
						// Set the width and height of the globe based on the container's size
						globe.width(container.offsetWidth).height(container.offsetHeight);
						
						// Manually reset the canvas element size to match the container size
						const canvas = document.querySelector('canvas');
						canvas.style.width = `${container.offsetWidth}px`;
						canvas.style.height = `${container.offsetHeight}px`;
						canvas.style.transform = 'none';
					};

					// Resize the globe on window resize
					window.addEventListener('resize', resizeGlobe);

					// Trigger the resize immediately after the globe is initialized
					resizeGlobe();
				}

				function updateTables(filtered_reentries) {
					
					// Flatten all groups into a single array of rows (with date sorting)
					let allRows = [];
					filtered_reentries.forEach(group => {
						group.id.forEach((location, index) => {
							const row = {
								date: group.date[index],
								location: location,
								time: group.time[index],
								name: group.name[index],
								objname: group.objname[index],
								category: group.category[index],
								smc: group.smc[index],
								al: group.al[index],
								nox: group.nox[index],
								bc: group.bc[index],
								hcl: group.hcl[index],
								cl: group.cl[index],
								unab_mass: group.unab_mass[index],
								groupName: group.name[index] // Keep track of the group name for later
							};
							allRows.push(row);
						});
					});

					// Sort rows by date
					allRows.sort((a, b) => new Date(a.date) - new Date(b.date));  // Ensure date is sorted from earliest to latest

					// Populate Re-entry Table
					const table2Body = document.getElementById('reentryTableBody');
					const table2Foot = document.getElementById('reentryTableFoot');
					table2Body.innerHTML = '';
					table2Foot.innerHTML = '';
					let totalal = 0, totalnox = 0, totalmass = 0;
					let totalbc = 0, totalhcl = 0, totalcl = 0;

					allRows.forEach(row => {
						const { date, location, time, name, objname, category, smc, al, nox, bc, hcl, cl, unab_mass } = row;

						const tableRow = document.createElement('tr');
						totalal += al;
						totalnox += nox;
						totalbc += bc;
						totalhcl += hcl;
						totalcl += cl;
						totalmass += unab_mass;
						tableRow.innerHTML = `
							<td>${date}</td>
							<td>${location}</td> 
							<td>${time.toFixed(2)}</td>
							<td class="wrap-text">${name}</td>
							<td class="wrap-text">${objname}</td>
							<td>${category}</td>
							<td>${smc}</td>
							<td>${al.toFixed(2)}</td>
							<td>${nox.toFixed(2)}</td>
							<td>${bc.toFixed(2)}</td>
							<td>${hcl.toFixed(2)}</td>
							<td>${cl.toFixed(2)}</td>
							<td>${unab_mass.toFixed(2)}</td>
							`;
						table2Body.appendChild(tableRow);
					});

					// Add Totals to Re-entry Table
					const totalRow2 = document.createElement('tr');
					totalRow2.innerHTML = `
						<td>Total</td>
						<td>-</td>
						<td>-</td>
						<td>-</td>
						<td>-</td>
						<td>-</td>
						<td>-</td>
						<td>${totalal.toFixed(2)}</td>
						<td>${totalnox.toFixed(2)}</td>
						<td>${totalbc.toFixed(2)}</td>
						<td>${totalhcl.toFixed(2)}</td>
						<td>${totalcl.toFixed(2)}</td>
						<td>${totalmass.toFixed(2)}</td>
					`;
					table2Foot.appendChild(totalRow2);
				}
				
				function updateMaps(filtered_reentries) {
					// Prepare the data for Plotly
					
					let plotlyData = [];
					Object.keys(filtered_reentries).forEach(locationGroup => {
						const groupData = filtered_reentries[locationGroup];
						plotlyData.push({
							type: 'scattergeo',
							mode: 'markers',
							name: groupNames[locationGroup],
							lat: groupData.lat,
							lon: groupData.lon,
							marker: {
								size: 12,
								color: groupData.color,
								symbol: 'x'
							},
							
							showlegend: true
						});
					});

					// Common layout configuration
					const commonLayout = {
						geo: {
							resolution: 100, 
							projection: { type: 'robinson' },
							showland: true,
							landcolor: 'rgb(217, 217, 217)',
							showocean: true,
							oceancolor: 'rgb(204, 233, 255)',
							showcountries: true,
							countrycolor: 'rgb(50, 50, 50)',
							showsubunits: true,
							subunitcolor: 'rgb(150, 150, 150)',
							showgrid: true,
							gridcolor: 'rgb(220, 220, 220)',
							gridwidth: 2,
							griddash: 'dash', // Dashed gridlines for both axes
							lataxis: {
								showgrid: true,  // Gridline for latitude axis
								gridcolor: 'rgb(220, 220, 220)', // Optional: specify grid color
								griddash: 'dash', // Dashed gridline style
								tickmode: 'array',
								ticks: '',
								ticklen: 10,
								tickcolor: 'rgb(220, 220, 220)',
								showticklabels: false,
								zeroline: false
							},
							lonaxis: {
								showgrid: true,  // Gridline for longitude axis
								gridcolor: 'rgb(220, 220, 220)', // Optional: specify grid color
								griddash: 'dash', // Dashed gridline style
								tickmode: 'array',
								ticks: '',
								ticklen: 10,
								tickcolor: 'rgb(220, 220, 220)',
								showticklabels: false,
								zeroline: false
							}
						},
						margin: { t: 50, b: 0, l: 0, r: 0 }, // Adjust top margin for title
						title: {text: 'Re-entries', font: { size: 18 }, xanchor: 'center', yanchor: 'top', y: 0 }, // Adjust title position
						showlegend: true,
						legend: {
							x: 0.5,
							y: -0.05,
							xanchor: 'center',
							orientation: 'h',
							traceorder: 'normal',
							font: { size: 14 },
							bgcolor: 'rgba(255, 255, 255, 0.5)',  // Slight transparent background
						},
					};
					
					const layout2 = { ...commonLayout};
					Plotly.newPlot('map1', plotlyData, layout2);
				}
				
				function updateGraph(filtered_reentries) {

					let totalal = 0, totalnox = 0, totalmass = 0;
					let totalbc = 0, totalhcl = 0, totalcl = 0;
					filtered_reentries.forEach(group => {
						group.id.forEach((location, index) => {
							const row  = document.createElement('tr');
							const al   = group.al[index];
							const nox  = group.nox[index];
							const bc   = group.bc[index];
							const hcl  = group.hcl[index];
							const cl   = group.cl[index];
							const mass = group.unab_mass[index];
							totalal += al;
							totalnox += nox;
							totalbc += bc;
							totalhcl += hcl;
							totalcl += cl;
							totalmass += mass;
						});
					});
					
					// Prepare the data for Plotly
					const labels = ['Al<sub>2</sub>O<sub>3</sub>', 'NO<sub>x</sub>', 'BC', 'HCl', 'Cl', 'Unablated Mass'];
					const data = [totalal, totalnox, totalbc, totalhcl, totalcl, totalmass];
					const maxYValue = Math.max(...data);

					const trace = {
						x: labels,
						y: data,
						type: 'bar',  // Bar chart (you can change to line, pie, etc.)
						marker: {
							color: 'rgba(75, 192, 192, 0.7)'
						}
					};

					const layout = {
						title: `Emissions between ${startDate} and ${endDate}`,
						xaxis: {
							title: 'Compound',
							font: {
								color: 'green', // Set x-axis label color
								size: 14        // x-axis font size
							}
						},
						yaxis: {
							title: 'Mass [t]',
							range: [0,maxYValue]
						},
						autosize: true,  // Automatically resize the chart
						responsive: true // Ensure the chart resizes with the window
					};

					// Plot the chart inside the 'emissionsChart' div
					Plotly.newPlot('bar1', [trace], layout);

				}
				
				// Plot a default date when the page opens, then update when the date changes.
				document.addEventListener('DOMContentLoaded', () => {

					const datePicker1 = document.getElementById('datePicker1'); // Start date picker
					const datePicker2 = document.getElementById('datePicker2'); // End date picker

					datePicker1.value = startDate;
					datePicker2.value = endDate;
					fetchEventsData(); // Fetch data for the default date

					// Event listeners for date pickers
					datePicker1.addEventListener('change', (event) => {
						startDate= event.target.value;
						if (startDate) {
							fetchEventsData();
						}
					});
					datePicker2.addEventListener('change', (event) => {
						endDate = event.target.value;
						if (endDate) {
							fetchEventsData();
						}
					});

					document.getElementById('applyFilters').addEventListener('click', () => {
						toggleContainer('globe');
						filterreentries(all_reentries);
					});
				});
				
				// JavaScript to toggle the table visibility and update the arrow
				const toggleButton = document.getElementById('toggleTableButton');
				const tableBody = document.getElementById('reentryTableBody');

				toggleButton.addEventListener('click', () => {
					const isHidden = tableBody.style.display === 'none';
					tableBody.style.display = isHidden ? 'table-row-group' : 'none';
					toggleButton.innerHTML = isHidden ? '&#9660;' : '&#9650;'; // Down arrow when shown, up arrow when hidden
				});

			</script> 
			<br>
			<a href="#">Go to Top</a>
			<br>
			<br>
			<h2>Frequently Asked Questions</h2>

			<div id="faqs-container"></div>

			<script>
				const faqData = [ 
					{ question: "What are these chemicals?",
					answer: "NO<sub>x</sub> is nitrogen oxides, BC is black carbon or soot, Al<sub>2</sub>O<sub>3</sub> is aluminium oxide or alumina, and Cl<sub>y</sub> is a family of chlorine compounds. NO<sub>x</sub> and Cl<sub>y</sub> are released as gases, BC and Al<sub>2</sub>O<sub>3</sub> as particles."
					},
					{ question: "How do these chemicals affect the atmosphere?",
						answer: "Re-entries release air pollutant emissions into the upper layers of the atmosphere, where they can have an outsized impact on our atmosphere and climate. NO<sub>x</sub> and Cl<sub>y</sub> are the largest contributors to destruction of the ozone layer from rocket emissions, with smaller destruction occuring from emissions of BC and Al<sub>2</sub>O<sub>3</sub> particles. The largest climate impacts come from BC emissions, which warm the upper layers of the atmosphere while cooling the lower layers."
						},
					{ question: "What does each filter represent?",
						answer: "Re-entry point allows users to filter for re-entering objects that are known and that we have had to approximate, as exact location data is not available. Known re-entries are further separated into Falcon and non-Falcon rocket and fairing re-entries.  Object Type distinguishes individual re-entering objects as Payload (P), C=Component (C1), Booster (B1-B4), and rocket stage (S1-S4). Megaconstellation allows users to select re-entries that are or are not associated with megaconstellation missions."
						},					
					{ question: "How is this data calculated?",
					answer: "Our calculations are based on the current best scientific knowledge available for emissions from object re-entries. We use object-specific ablation profiles to calculate alumina emissions from object re-entries, including all objects with an apogee above 50 km. Paths shown in the Globe view are fixed at the re-entry location and do not represent real object trajectories."
					},
					{ question: "Where can I find the original methodology and data?",
					answer: "You can find further details in our study published in Nature Scientific Data: Global 3D rocket launch and re-entry air pollutant and carbon dioxide emissions for 2020-2022</strong>. C. R. Barker, E. A. Marais (2024). doi:10.5522/04/26325382. [<a href='https://doi.org/10.5522/04/26325382' target='_blank' rel='noopener noreferrer'>Data</a>]. [<a href='https://www.nature.com/articles/s41597-024-03910-z' target='_blank' rel='noopener noreferrer'>Publication</a>]</p>"
					}
				];

				const faqsContainer = document.getElementById('faqs-container');

				faqData.map(function(item) {

					let article = document.createElement('article');
					article.classList.add('faq-item');

					const markup = `
							<div class="item-question">
								<span class="question-text">${item.question}</span>
								<span class="arrows-container">
									<span class="expand">▼</span>
									<span class="close">▲</span>
								</span>
							</div>
							<div class="item-answer">
								<span>${item.answer}</span>
							</div>
					`;
					
					article.innerHTML = markup;
					faqsContainer.append(article);
				});

				const toggleButtons = document.querySelectorAll('.arrows-container');
					
				toggleButtons.forEach(button => {
					button.addEventListener('click', function(e) {
						const faqItem = e.currentTarget.parentElement.parentElement;
						faqItem.classList.toggle("show-answer");
					});
				});

			</script>

			<p>
				Developed by <a href="https://profiles.ucl.ac.uk/93616-connor-barker" target="_blank" rel="noopener noreferrer">Connor Barker</a> (UCL postdoc) and <a href="https://profiles.ucl.ac.uk/77783-eloise-marais" target="_blank" rel="noopener noreferrer">Eloise Marais</a> (UCL PI), in collaboration with <a href="https://www.cfa.harvard.edu/people/jonathan-mcdowell" target="_blank" rel="noopener noreferrer">Jonathan McDowell</a> (Harvard-Smithsonian Center for Astrophysics) and Eric Tan (UCL Department of Astrophysics). Interested in using the data or spot any room for improvements? Please reach out to Connor Barker at <a href= "mailto:name@email.com">connor.barker@ucl.ac.uk</a>.
			</p>
			<p>
				<strong>Funding Disclaimer:</strong> This project has received funding from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement No. 851854). <a href="https://cordis.europa.eu/project/id/851854" target="_blank" rel="noopener noreferrer">European Commission project page</a>.
			</p>
		</div>
		</div>
	</div>
</div>

<hr />
<div id="footer">
	<p>
		<br> <br />
	</p>
</div>
<script type="text/javascript' src='./js/wp-embed.min.js"></script>
</body>
</html>