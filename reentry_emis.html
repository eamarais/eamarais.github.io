<!doctype html>
<html lang="en">
<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Object Re-entry Emissions</title>
<link rel="icon" type="image/x-icon" href="images/favicon_satellite.ico">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<link rel="stylesheet" href="style.css" type="text/css" media="screen" />
<style>
	#page { background: url("./themes/default/images/kubrickbgwide.jpg") repeat-y top; border: none; }
</style>

<script src="https://cdn.plot.ly/plotly-3.0.3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/globe.gl"></script>
<script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-L03HTPL2E2"></script>
<script>
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-L03HTPL2E2');
</script>

</head>

<body>

<div id="page">
		
	<div id="header">

		<!--Header image-->
		<div id="headerimg">
			<h1>
				<a style="color:black" href="http://maraisresearchgroup.co.uk/">
					<div class="transparent-box">Atmospheric Composition and Air Quality Group</div>
				</a>
			</h1>
		</div>

		<!--Navigation bar-->
		<div id="navmenu">
			<iframe src="./nav.html" onload="this.before((this.contentDocument.body||this.contentDocument).children[0]);this.remove()"></iframe>
		</div>

	</div>

	<hr/>

	<div id="content" class="widecolumn">

		<div class="post" id="post-3">
			<h2>Emissions from Artificial Object Re-entries</h2>
					
			<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous" referrerpolicy="no-referrer" />
			<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.7.0/dist/nouislider.min.css">

			<link rel="preconnect" href="https://fonts.googleapis.com">
			<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
			<link href="https://fonts.googleapis.com/css2?family=Inter+Tight:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
			
			<style>

				html>body {
					line-height: normal;

				}

				#content {
					font-family: "Inter Tight", sans-serif;
					font-optical-sizing: auto;
					font-weight: 400;
					font-style: normal;
					font-size: 1.3em;
				}

				*, ::after, ::before {
					box-sizing: content-box !important;
				}

				#slider, 
				#slider * {
					box-sizing: border-box !important;
				}

				p {
					margin-top: 12.6px !important;
					margin-bottom: 12.6px !important;
				}


				.filter-container {
					display: flex;
					justify-content: space-around;
					align-items: center;
					margin: 0px 0px 20px 0px;
					gap: 10px;
				}

				.filter {
					position: relative;
					background: #143d59;
					color: whitesmoke;
					padding: 0.25rem;
					height: 15px;
					cursor: pointer; /* show pointer on hover */
				}

				.filter label {
					font-size: 1.125em;
					user-select: none;
					display: inline-flex;
					align-items: center;
					gap: 6px;
					position: relative;
				}

				.filter label::after {
					content: '';
					display: inline-block;
					width: 0; 
					height: 0; 
					border-left: 5px solid transparent;
					border-right: 5px solid transparent;
					border-top: 5px solid whitesmoke;
					vertical-align: middle;
					transition: transform 0.3s ease;
					margin-left: 6px;
				}

				/* Arrow down (open) */
				.filter.open label::after {
					transform: rotate(180deg);
				}

				/* Remove any arrows from dropdown labels */
				.dropdown label::after {
					display: none !important;
					content: none !important;
				}
				/* Hide dropdown initially */
				.dropdown ul {
					display: none;
					position: absolute;
					left:50%;
					transform: translateX(-50%);
					list-style-type: none;
					background-color: #8dc4ee;
					max-height: 300px;
					overflow-y: auto;
					width: auto;
					min-width: 150px; /* Ensure a minimum width */
					white-space: nowrap;
					border-radius: 5px;
					z-index: 100;
					top: 10px;
				}

				.dropdown label {
					font-size: 1.2em;
					display: flex;
					align-items: center;
					gap: 15px;
					padding: 0;
				}

				.filter.open .dropdown ul {
					display: block;
					padding: 0px;
				}

				.entry ul li:before {
					display: none;
				}

				html>body .entry li {
					margin: 7px;
				}

				.wrap-text {
					white-space: normal;
					word-wrap: break-word;
					max-width: 500px; /* Adjust the width as needed */
				}

				#map {
					width: 100%;
					height: 100%;  /* or 100%, or whatever fits your layout */
					margin: 0;
					padding: 0;
				}

				/* Style for the tabs */
				.tabs {
					display: flex;
					cursor: pointer;
					margin-bottom: 10px;
				}

				.globe .map .chart {
					height: 100%;
				}

				.tab {
					padding: 5px;
					background-color: #143d59;
					border: 1px solid #ccc;
					border-radius: 5px;
					color: whitesmoke;
				}

				#myTab {
					padding-left: 0;
				}

				#myTabContent {
					padding: 15px 0px 15px 0px;
				}

				.nav-tabs{
					border: 0px;
					font-size: 1.5em;
				}

				.nav-tabs .nav-item {
					padding: 0px 30px 0px 0px;
					margin: 0 0 0 0;
				}

				.nav-tabs .nav-link {
					background-color: #143d59;
					color: whitesmoke;
					margin-bottom: 0px;
					border: 5px solid transparent;
					border-bottom-left-radius: 0px;
					padding: 5px;
				}

				.nav-tabs .nav-link:hover {
					background-color: #246a99;
					border-color: transparent;
				}

				.nav-tabs .nav-link.active {
					background-color: #588db1;
					font-weight: bold;
					color: whitesmoke;
					border-color: #588db1;
					box-shadow: inset 0 0 0 0 transparent, 0 0 0 0 transparent, inset 0px 0 0 0 transparent, 0 5px 0 0 #143d59;
				}

				.nav-tabs-container {
					border-bottom: 5px solid #e9e9e9; /* or your desired color */
					margin-bottom: 10px; /* spacing below the line */
				}

				/* Container to align the tables side by side */
				.table-container {
					display: flex;
					justify-content: space-between;
					gap: 20px;
					position: relative;
					padding: 15px 0px 15px 0px;
				}

				/* Table styling */
				table {
					width: 100%;
					margin-top: 20px;
					border-collapse: collapse;
					padding: 10px;
					white-space: nowrap;
				}

				th, td {
					padding: 10px;
					text-align: left;
					border: 1px solid #ddd;
					white-space: nowrap;
				}

				th {
					background-color: #f4f4f4;
				}

				tfoot {
					font-weight: bold;
					background-color: #f9f9f9;
				}

				.faq-item {
					display: block;

					/*width: 38vw;
					min-width: 350px;*/
					margin-top: 0.5rem;
				}
				.item-question {
					background: #143d59;
					color: whitesmoke;
					font-size: 1rem;
					padding: 0.5rem;
					display: flex;
					justify-content: space-between;
					align-items: center;
				}
				.question-text {
					display: inline-block;
				}
				.arrows-container {
					margin: 0.4rem;
				}
				.item-answer {
					display: none;
					color: rgb(0, 0, 0);
					padding: 2rem;
				}
				.close {
					display: none;
				}

				.show-answer .item-answer {
					display: block;
					background: #8dc4ee;
				}
				.show-answer .close {
					display: inline;
				}
				.show-answer .expand {
					display: none;
				}

				/* Style for the arrow button */
				.arrow-button {
					background: #143d59;
					border: none;
					margin: none;
					color: whitesmoke;	
					padding: 0px;		
					font-size: 1rem; /* Increase size for better visibility */
					position: absolute; /* Position relative to the table container */
					top: 86px; /* Align with the top of the table */
					left: -39px; /* Place the button outside the table on the right */
					width: 39px;
					height: 39px;
					z-index: 10; /* Ensure the button is above other elements */
				}

				.arrow-button:focus {
					outline: none;
				}

				.noUi-horizontal {
					height: 5px;
				}

				.noUi-target {
					border: none;
					background: #e9e9e9;
				}

				.noUi-value {
					margin-top: 8px;
				}

				.noUi-tooltip {
					padding: 0px;
					border: 0px;
				}

				.noUi-connect {
					background: #588db1;;
				}

				.noUi-handle {
					background: #143d59;
					box-shadow: none;
					border: 0px;
					border-radius: 50%; 
				}

				.noUi-handle:before,
				.noUi-handle:after {
					display: none;
				}

				.noUi-pips-horizontal {
					padding: 3px;
				}

				.noUi-horizontal .noUi-handle{
					width: 20px;
					height: 20px;
					color: #000000;
					right: -10px;
					top: -7px;
				}

				.noUi-pips-horizontal{
					height: 10px;
				}

			</style>

			<div class="entry">
				<!-- Preamble to setup the content -->
				<p>
					Welcome to our tracker for objects re-entering the atmosphere since the start of the megaconstellation era. Select a time window of interest to visualise the location and ID of each re-entry for the time windows, mission type, and object categories selected. Bars total the corresponding emissions and intact (unablated) mass. For more information, see the <a href="#faqs-container">FAQs</a>  at the bottom of this page. Large ranges may be slow to load.<br/> 
				</p>
				<br>
				<div class="filter-container">
					<div id="slider" style="width: 400px; margin-left:35px; margin-right:35px;"></div>
					<div class="filter">
						<label>Re-entry Point</label>
						<div class="dropdown" id="locationFilter">
							<ul></ul>
						</div>
					</div>
				
					<div class="filter">
						<label>Object Type</label>
						<div class="dropdown" id="categoryFilter">
							<ul></ul>
						</div>
					</div>
				
					<div class="filter">
						<label>Megaconstellation</label>
						<div class="dropdown" id="smcFilter">
							<ul></ul>
						</div>
					</div>
					
				</div>
				<br>

				<!-- Tabs for globe and map -->
				<div class="nav-tabs-container d-flex justify-content-between align-items-center">
					<ul class="nav nav-tabs" id="myTab" role="tablist">
						<li class="nav-item" role="presentation">
						<button class="nav-link active" id="chart-tab" data-bs-toggle="tab" data-bs-target="#chart" type="button" role="tab" aria-controls="chart" aria-selected="true">Emissions Data</button>
						</li>
						<li class="nav-item" role="presentation">
						<button class="nav-link"        id="globe-tab" data-bs-toggle="tab" data-bs-target="#globe" type="button" role="tab" aria-controls="globe" aria-selected="false">3D Globe</button>
						</li>
						<li class="nav-item" role="presentation">
						<button class="nav-link"        id="map-tab"   data-bs-toggle="tab" data-bs-target="#map"   type="button" role="tab" aria-controls="map"   aria-selected="false">2D Map</button>
						</li>
					</ul>
					<button class="tab" type="submit" id="applyFilters">Apply Filters</button>
				</div>

				<div class="tab-content" id="myTabContent">
					<div class="tab-pane fade show active" id="chart"   role="tabpanel" aria-labelledby="chart-tab">
						<div class="row">
							<div class="col-8" style="padding:0px;"> <!-- 75% -->
								<div id="stack" class="chart"></div>
							</div>
							<div class="col-4" style="padding:0px;"> <!-- 25% -->
								<div id="bar" class="chart"></div>
							</div>
						</div>
					</div>
					<div class="tab-pane fade"             id="globe"   role="tabpanel" aria-labelledby="globe-tab">
						<div id="globe" class="globe"></div>
					</div>
					<div class="tab-pane fade"             id="map"     role="tabpanel" aria-labelledby="map-tab">
						<div id="map" class="map"></div> 
					</div>
				</div>

				<!-- Table for Re-entry Locations -->
				<div class="table-container">
					<div>
						<h3 style="margin: 0px;">Re-entry Details (Click arrow to expand)</h3>
						<p>[Emissions in tonnes, time in UTC. SMC=Satellite Megaconstellation, Cat=Category, P=Payload, C=Component, B=Booster, S=Stage.]</p>
						<table id="reentryTable">
							<thead>
								<tr>
									<th>Date</th>
									<th>ID</th>
									<th>Time</th>
									<th>Location</th>
									<th>Name</th>
									<th>Cat</th>
									<th>SMC</th>
									<th>AlO<sub>x</sub></th>
									<th>NO<sub>x</sub></th>
									<th>BC</th>
									<th>HCl</th>
									<th>Cl</th>
									<th>Unablated Mass</th>
								</tr>
							</thead>
							<tbody id="reentryTableBody" style="display: none;">
								<!-- Dynamic rows for re-entry locations will be inserted here -->
							</tbody>
							<tfoot id="reentryTableFoot">
								<!-- Totals for launches -->
							</tfoot>
							<button id="toggleTableButton" class="arrow-button">&#9650;</button>
						</table>
					</div>
				</div>

				<script>

					const startYear = 2020;
					const endYear = 2024;
					const totalMonths = (endYear - startYear + 1) * 12;
					let globe;
					let groupNames = ["Known (Falcon)", "Known (non-Falcon)", "Approximate"];

					function indexToDate(index) {
						const year = startYear + Math.floor(index / 12);
						const intIndex = Math.floor(Number(index)); 
						const month = intIndex % 12;
						return `01/${String(month + 1).padStart(2, '0')}/${year}`;
					}

					function intToDateString(monthIndex) {

						// Calculate year and month offset
						const year = 2020 + Math.floor(monthIndex / 12);
						const month = (monthIndex % 12);

						// Build date object (day 1 of the month)
						const date = new Date(year, month, 1);

						// Format YYYY-MM-DD
						const yyyy = date.getFullYear();
						const mm = String(date.getMonth() + 1).padStart(2, '0'); // month is 0-based
						const dd = String(date.getDate()).padStart(2, '0');

						return `${yyyy}-${mm}-${dd}`;
					}

					noUiSlider.create(slider, {
						start: [48, 60],
						connect: true,
						step: 1,
						range: {
							min: 0,
							max: totalMonths,
						},
						tooltips: [        
							{
								to: value => indexToDate(value),
								from: () => 0
							},
							{
								to: value => indexToDate(value),
								from: () => 0
							}
						],
						format: {
							to: value => Math.round(value),
							from: value => Number(value)
						},
						pips: {
							mode: 'steps',
							density: 12,
							filter: function(value) {
								// Show label only every 12 months (1 year)
								return (value % 12 === 0) ? 1 : 0;  // 1 = show label, 0 = hide
							},
							format: {
								to: function(value) {
									// label only for year start (Jan)
									return value % 12 === 0 ? (startYear + value / 12) : '';
								}
							}
						}
					});	
					
					slider.noUiSlider.on('end', (values, handle) => {
						// values is an array of current slider values as strings
						// handle is 0 (left handle) or 1 (right handle)

						startDate = intToDateString(Number(values[0]));
						endDate = intToDateString(Number(values[1]));
						console.log(startDate, endDate);
						fetchEventsData(); // Fetch data 

						// Now update your data or UI based on leftValue and rightValue
						//updateMyData(leftValue, rightValue);
					});

					const locationGroups = {
								"Known (Falcon)": [5],
								"Known (non-Falcon)": [1,2,3,4], 
								"Approximate": [6,7]
							};
					
					function populateFilters(reentries) {
						// Get unique values from filtered_reentries for each filter
						const categories = [...new Set(reentries.flatMap(group => group.category))].sort();
						const smcValues = [...new Set(reentries.flatMap(group => group.smc))];

						// Function to populate checkboxes inside a given filter dropdown
						function populateCheckboxes(filterId, values) {
							const dropdown = document.getElementById(filterId);
							const ul = dropdown.querySelector('ul');
							ul.innerHTML = ''; // Clear any previous entries

							values.forEach(value => {
								const li = document.createElement('li');
								li.innerHTML = `<label><input type="checkbox" value="${value}" /> ${value}</label>`;
								ul.appendChild(li);
							});
						}

						// Populate each filter
						populateCheckboxes('locationFilter', groupNames);
						populateCheckboxes('categoryFilter', categories);
						populateCheckboxes('smcFilter', smcValues);
					}

					function filterreentries(all_reentries) {

						function getSelectedfilters(filter) {
							const var_filter = document.getElementById(filter);
							const checkboxes = var_filter.querySelectorAll('input[type="checkbox"]:checked');
							return Array.from(checkboxes).map(checkbox => checkbox.value);
						}

						// Get selected values from each filter
						const selectedReusabilities = getSelectedfilters('locationFilter');
						const selectedCategories    = getSelectedfilters('categoryFilter');
						const selectedSmc           = getSelectedfilters('smcFilter');

						
						// Create an empty array to store the filtered results, maintaining group structure
						let filteredData = all_reentries.map((group, groupIndex) => {
							// Check if the entire group should be excluded
							const groupName = groupNames[groupIndex];
							if (selectedReusabilities.length > 0 && !selectedReusabilities.includes(groupName)) {
								return null; // Exclude this group
							}

							// Get all indices initially
							let indicesToKeep = [...Array(group.date.length).keys()];

							// Filter by category
							if (selectedCategories.length > 0) {
								indicesToKeep = indicesToKeep.filter(i => selectedCategories.includes(group.category[i]));
							}

							// Filter by SMC
							if (selectedSmc.length > 0) {
								indicesToKeep = indicesToKeep.filter(i => selectedSmc.includes(group.smc[i]));
							}

							// Return the filtered group (keeping the structure)
							return {
								date: indicesToKeep.map(i => group.date[i]),
								id: indicesToKeep.map(i => group.id[i]),
								time: indicesToKeep.map(i => group.time[i]),
								smc: indicesToKeep.map(i => group.smc[i]),
								lat: indicesToKeep.map(i => group.lat[i]),
								lon: indicesToKeep.map(i => group.lon[i]),
								category: indicesToKeep.map(i => group.category[i]),
								name: indicesToKeep.map(i => group.name[i]),
								objname: indicesToKeep.map(i => group.objname[i]),
								al: indicesToKeep.map(i => group.al[i]),
								nox: indicesToKeep.map(i => group.nox[i]),
								bc: indicesToKeep.map(i => group.bc[i]),
								hcl: indicesToKeep.map(i => group.hcl[i]),
								cl: indicesToKeep.map(i => group.cl[i]),
								unab_mass: indicesToKeep.map(i => group.unab_mass[i])
							};
						});

						// Remove null entries (groups that were excluded by the filter)
						filteredData = filteredData.filter(group => group !== null);

						// Update the visualizations with the filtered data
						updateVisualizations(filteredData);
					}
					
					async function fetchEventsData() {
						try {
							// Fetch the data from the API (replace with your actual API URL)
							const response = await fetch(`https://cbarker.pythonanywhere.com/api/reentries?start_date=${startDate}&end_date=${endDate}`); // Replace with your actual API URL
							const reentryData = await response.json();
							const reentriesByCategory = {};
							
							// Helper function to assign colors based on the location category
							function getColorForCategory(cat) {
								switch (cat) {
									case 'Known (Falcon)':
										return 'green';
									case 'Known (non-Falcon)':
										return 'blue';
									case 'Approximate':
										return 'red';
									default:
										return 'gray'; // Default color for unknown categories
								}
							}

							function getLocationGroup(locationNumber) {
								for (const [groupName, locations] of Object.entries(locationGroups)) {
									if (locations.includes(locationNumber)) {
										return groupName; // Return the group name if the location is found
									}
								}
								return "Unknown Location"; // Fallback for ungrouped locations
							}

							function createReentryCategory(categoryName) {
								return {
									date: [],
									id: [],
									time: [],
									name: [],
									objname: [],
									lat: [],
									lon: [],
									smc: [],
									category: [],
									color: getColorForCategory(categoryName),
									al: [],
									nox: [],
									bc: [],
									hcl: [],
									cl: [],
									unab_mass: []
								};
							}

							reentriesByCategory['Known (Falcon)'] = createReentryCategory('Known (Falcon)');
							reentriesByCategory['Known (non-Falcon)'] = createReentryCategory('Known (non-Falcon)');
							reentriesByCategory['Approximate'] = createReentryCategory('Approximate');

							Object.keys(reentryData).forEach(date => {
								reentryData[date].reentries.forEach(reentry => {
									
									const locationGroup = getLocationGroup(reentry.location);
									
									// Add reentry data to the category group
									reentriesByCategory[locationGroup].date.push(reentry.date);
									reentriesByCategory[locationGroup].id.push(reentry.id);
									reentriesByCategory[locationGroup].time.push(reentry.time);
									reentriesByCategory[locationGroup].smc.push(reentry.smc ? "Yes" : "No");
									reentriesByCategory[locationGroup].lat.push(reentry.lat);
									reentriesByCategory[locationGroup].name.push(locationGroup);
									reentriesByCategory[locationGroup].category.push(reentry.category);
									reentriesByCategory[locationGroup].lon.push(reentry.lon);
									reentriesByCategory[locationGroup].objname.push(reentry.name);
									reentriesByCategory[locationGroup].al.push(reentry.emissions.Al2O3);
									reentriesByCategory[locationGroup].nox.push(reentry.emissions.NOx);
									reentriesByCategory[locationGroup].bc.push(reentry.emissions.BC);
									reentriesByCategory[locationGroup].hcl.push(reentry.emissions.HCl);
									reentriesByCategory[locationGroup].cl.push(reentry.emissions.Cl);
									reentriesByCategory[locationGroup].unab_mass.push(reentry.emissions.Unablated_Mass);
								});
							});

							// Combine the arrays into the desired structure and update the visualisations.
							all_reentries = Object.values(reentriesByCategory);

							populateFilters(all_reentries);
							updateVisualizations(all_reentries);

						} catch (error) {
							console.error('Error fetching or processing the events data:', error);
						}
					}

					function updateVisualizations(filtered_reentries) {
						updateTables(filtered_reentries);
						updateMaps(filtered_reentries);
						updateGraph(filtered_reentries);
						updateGlobe(filtered_reentries);
						updateStack(filtered_reentries);
					}

					const prettyNames = {
						bc: 'BC',
						unab_mass: 'Unablated Mass',
						cl: 'Cl',
						al: 'AlO<sub>x</sub>',
						hcl: 'HCl',
						nox: 'NO<sub>x</sub>'
					};

					const strongColors = {
						bc: 'rgba(0,0,0,1)',
						unab_mass: '#575757',
						cl: '#2c20c9',
						al: '#c40000',
						hcl: '#1cba26',
						nox: '#c99b24'
					};

					function updateGlobe(filtered_reentries) {

						const allGData = [];

						filtered_reentries.forEach(locationSet => {
							const gData = locationSet.lat.map((latitude, index) => {
								const longitude = locationSet.lon[index];
		
								return {
									lat: latitude,
									lon: longitude,
									name: `Re-entry ID ${locationSet.id[index]}`,
								};
							});

							allGData.push(...gData);
						});

						const OPACITYPATH  = 0.3;
						
						if (!globe) {
							globe = new Globe(document.getElementById('globe'))
								.globeImageUrl('https://cdn.jsdelivr.net/npm/three-globe/example/img/earth-blue-marble.jpg')
								.pointLat(d => d.lat)
								.pointLng(d => d.lon)
								.pointColor(() => `rgba(255, 0, 0, ${OPACITYPATH})`)
								.pointRadius(0.5)
								.pointAltitude(0.2)
								.onPointHover(hoverPoint => {
									globe
									.pointColor(d => {
										const op = !hoverPoint ? OPACITYPATH : d === hoverPoint ? 0.9 : 0;
										return `rgba(255, 0, 0, ${op})`;
									})
									.labelSize(d => {
										// Show label only if this label matches the hovered point
										return hoverPoint && d.name === hoverPoint.name ? 1.5 : 0;
									});
								});
							
							globe.pointsData(allGData);

							setTimeout(() => {
							globe
								.pointOfView({ lat: 0, lng: 0, altitude: 1.9 }, 1000);
							}, 0);

						} else {
							globe.pointsData(allGData);
						}
					}

					function updateTables(filtered_reentries) {
						
						// Flatten all groups into a single array of rows (with date sorting)
						let allRows = [];
						filtered_reentries.forEach(group => {
							group.id.forEach((location, index) => {
								const row = {
									date: group.date[index],
									location: location,
									time: group.time[index],
									name: group.name[index],
									objname: group.objname[index],
									category: group.category[index],
									smc: group.smc[index],
									al: group.al[index],
									nox: group.nox[index],
									bc: group.bc[index],
									hcl: group.hcl[index],
									cl: group.cl[index],
									unab_mass: group.unab_mass[index],
									groupName: group.name[index] // Keep track of the group name for later
								};
								allRows.push(row);
							});
						});

						// Sort rows by date
						allRows.sort((a, b) => new Date(a.date) - new Date(b.date));  // Ensure date is sorted from earliest to latest

						// Populate Re-entry Table
						const table2Body = document.getElementById('reentryTableBody');
						const table2Foot = document.getElementById('reentryTableFoot');
						table2Body.innerHTML = '';
						table2Foot.innerHTML = '';
						let totalal = 0, totalnox = 0, totalmass = 0;
						let totalbc = 0, totalhcl = 0, totalcl = 0;

						allRows.forEach(row => {
							const { date, location, time, name, objname, category, smc, al, nox, bc, hcl, cl, unab_mass } = row;

							const tableRow = document.createElement('tr');
							totalal += al;
							totalnox += nox;
							totalbc += bc;
							totalhcl += hcl;
							totalcl += cl;
							totalmass += unab_mass;
							tableRow.innerHTML = `
								<td>${date}</td>
								<td>${location}</td> 
								<td>${time.toFixed(2)}</td>
								<td class="wrap-text">${name}</td>
								<td class="wrap-text">${objname}</td>
								<td>${category}</td>
								<td>${smc}</td>
								<td>${al.toFixed(2)}</td>
								<td>${nox.toFixed(2)}</td>
								<td>${bc.toFixed(2)}</td>
								<td>${hcl.toFixed(2)}</td>
								<td>${cl.toFixed(2)}</td>
								<td>${unab_mass.toFixed(2)}</td>
								`;
							table2Body.appendChild(tableRow);
						});

						// Add Totals to Re-entry Table
						const totalRow2 = document.createElement('tr');
						totalRow2.innerHTML = `
							<td>Total</td>
							<td>-</td>
							<td>-</td>
							<td>-</td>
							<td>-</td>
							<td>-</td>
							<td>-</td>
							<td>${totalal.toFixed(2)}</td>
							<td>${totalnox.toFixed(2)}</td>
							<td>${totalbc.toFixed(2)}</td>
							<td>${totalhcl.toFixed(2)}</td>
							<td>${totalcl.toFixed(2)}</td>
							<td>${totalmass.toFixed(2)}</td>
						`;
						table2Foot.appendChild(totalRow2);
					}
					
					function updateMaps(filtered_reentries) {
						
						let plotlyData = [];
						Object.keys(filtered_reentries).forEach(locationGroup => {
							const groupData = filtered_reentries[locationGroup];
							plotlyData.push({
								type: 'scattergeo',
								mode: 'markers',
								name: groupNames[locationGroup],
								lat: groupData.lat,
								lon: groupData.lon,
								marker: {
									size: 12,
									color: groupData.color,
									symbol: 'x'
								},
								textfont: {
									size: 15,  // Font size for the labels
									color: 'black',  // Color of the text
									weight: 'bold',
									family: 'Inter Tight, sans-serif',
								},
								showlegend: true
							});
						});

						const layout = {
							geo: {
								resolution: 100, 
								projection: { type: 'robinson' },
								showland: true,
								landcolor: 'rgb(217, 217, 217)',
								showocean: true,
								oceancolor: 'rgb(204, 233, 255)',
								showcountries: true,
								countrycolor: 'rgb(50, 50, 50)',
								showsubunits: true,
								subunitcolor: 'rgb(150, 150, 150)',
								showgrid: true,
								gridcolor: 'rgb(220, 220, 220)',
								gridwidth: 2,
								griddash: 'dash', // Dashed gridlines for both axes
								lataxis: {
									showgrid: true,  // Gridline for latitude axis
									gridcolor: 'rgb(220, 220, 220)', // Optional: specify grid color
									griddash: 'dash', // Dashed gridline style
									tickmode: 'array',
									ticks: '',
									ticklen: 10,
									tickcolor: 'rgb(220, 220, 220)',
									showticklabels: false,
									zeroline: false
								},
								lonaxis: {
									showgrid: true,  // Gridline for longitude axis
									gridcolor: 'rgb(220, 220, 220)', // Optional: specify grid color
									griddash: 'dash', // Dashed gridline style
									tickmode: 'array',
									ticks: '',
									ticklen: 10,
									tickcolor: 'rgb(220, 220, 220)',
									showticklabels: false,
									zeroline: false
								}
							},
							autosize: true,  // Automatically resize the chart
							margin: {
								l: 40,
								r: 40,
								t: 40,
								b: 40  // <- reduce bottom margin here
							},
							showlegend: true,
							legend: {
								x: 0.5,
								y: -0.05,
								xanchor: 'center',
								orientation: 'h',
								traceorder: 'normal',
								font: { size: 14 },
								bgcolor: 'rgba(255, 255, 255, 0.5)',  // Slight transparent background
							},
						};
						
						Plotly.newPlot('map', plotlyData, layout, {responsive: true});
					}
					
					function updateGraph(filtered_reentries) {

						const totals = {
							al: 0,
							nox: 0,
							unab_mass: 0,
							bc: 0,
							hcl: 0,
							cl: 0
						};

						filtered_reentries.forEach(group => {
							group.id.forEach((location, index) => {
								totals.al        += group.al[index];
								totals.nox       += group.nox[index];
								totals.unab_mass += group.unab_mass[index];
								totals.bc        += group.bc[index];
								totals.hcl       += group.hcl[index];
								totals.cl        += group.cl[index];
							});
						});
						
						// Prepare the data for Plotly
						const maxYValue = Object.values(totals).reduce((sum, val) => sum + val, 0);
						
						const trace = Object.keys(totals).map(key => ({
							x: ['Total'],
							y: [totals[key] / 1000],
							name: prettyNames[key],
							type: 'bar',
							marker: {color: strongColors[key]}
						}));
						
						const layout = {
							paper_bgcolor: 'rgba(0,0,0,0)',
							plot_bgcolor: 'rgba(0,0,0,0)',
							font: {
								size: 15,  // Font size for the labels
								family: 'Inter Tight, sans-serif',
							},
							title: {
								text: 'Total Emissions',
							},
							barmode: 'stack',
							yaxis: {
								range: [0,maxYValue / 1000]
							},
							legend: {
								orientation: 'v',
								x: 1.05,
								y: 1,
								itemwidth: 3,
								font: {
									size: 13,  // Font size for the legend
									family: 'Inter Tight, sans-serif',
								}
							},
							autosize: true,  // Automatically resize the chart
							margin: {
								l: 40,
								r: 40,
								t: 40,
								b: 20  // <- reduce bottom margin here
							}
						};

						// Plot the chart inside the 'emissionsChart' div
						Plotly.newPlot('bar', trace, layout, {responsive: true});

					}

					function updateStack(filtered_reentries) {

						const species = ['al', 'nox', 'unab_mass', 'bc', 'hcl', 'cl'];
						const monthlySums = {};

						// Step 1: Loop through each launch (index)
						filtered_reentries.forEach(reentryGroup => {
							for (let i = 0; i < reentryGroup.date.length; i++) {
								const month = reentryGroup.date[i].slice(0, 7);  // 'YYYY-MM'
								
								if (!monthlySums[month]) {
									monthlySums[month] = {};
									species.forEach(sp => monthlySums[month][sp] = 0);
								}
								
								species.forEach(sp => {
									monthlySums[month][sp] += Number(reentryGroup[sp][i]) || 0; // Ensure numeric
								});
							}
						});

						const months = Object.keys(monthlySums).sort();
						const maxYValue = Math.max(...months.map(month =>	species.reduce((sum, sp) => sum + monthlySums[month][sp], 0)));

						const traces = species.map(sp => ({
							x: months,
							y: months.map(m => monthlySums[m][sp] / 1000),
							stackgroup: 'one',
							name: prettyNames[sp],
							type: 'scatter',
							mode: 'none',
							fillcolor: strongColors[sp]
						}));

						const layout = {
							paper_bgcolor: 'rgba(0,0,0,0)',
							plot_bgcolor: 'rgba(0,0,0,0)',
							autosize: true,
							title: {
								text: 'Monthly Emissions (click legend to show/hide species)',
							},
							font: {
								size: 15,  // Font size for the labels
								family: 'Inter Tight, sans-serif',
							},
							yaxis: {
								title: {
									text: 'Mass [kilotonnes]',
								},
								range: [0,maxYValue / 1000]
							},
							legend: {
								orientation: 'v',
								x: 1.05,
								y: 1,
								font: {
									size: 13,  // Font size for the legend
									family: 'Inter Tight, sans-serif',
								}
							},
							autosize: true,  // Automatically resize the chart
							margin: {
								l: 60,
								r: 40,
								t: 40,
								b: 20  // <- reduce bottom margin here
							}
						};

						Plotly.newPlot('stack', traces , layout, {responsive: true});

					}
					
					// Plot a default date when the page opens, then update when the date changes.
					document.addEventListener('DOMContentLoaded', () => {

						const daterange = slider.noUiSlider.get();
						startDate = intToDateString(Number(daterange[0]));
						endDate = intToDateString(Number(daterange[1]));
						fetchEventsData(); // Fetch data for the default date

						document.getElementById('applyFilters').addEventListener('click', () => {
							filterreentries(all_reentries);
						});

						const tabEls = document.querySelectorAll('button[data-bs-toggle="tab"]');
						tabEls.forEach(function (tab) {
							tab.addEventListener('shown.bs.tab', function (event) {
								const activatedTabId = event.target.id;
								if (activatedTabId === 'chart-tab') {
									// Resize your Plotly charts
									Plotly.Plots.resize(document.getElementById('stack'));
									Plotly.Plots.resize(document.getElementById('bar'));
								}
								if (activatedTabId === 'globe-tab') {
									// Resize your Globe.gl renderer (assuming you have one)
									if (window.globe) {
										resizeGlobe();
									}
								}
								if (activatedTabId === 'map-tab') {
									// Resize Plotly map (if you're using Plotly for map)
									Plotly.Plots.resize(document.getElementById('map'));
								}
							});
						});
					});

					// JavaScript to toggle the table visibility and update the arrow
					const toggleButton = document.getElementById('toggleTableButton');
					const tableBody = document.getElementById('reentryTableBody');

					toggleButton.addEventListener('click', () => {
						const isHidden = tableBody.style.display === 'none';
						tableBody.style.display = isHidden ? 'table-row-group' : 'none';
						toggleButton.innerHTML = isHidden ? '&#9660;' : '&#9650;'; // Down arrow when shown, up arrow when hidden
					});

					document.querySelectorAll('.filter').forEach(filter => {
						filter.addEventListener('click', e => {
							// Prevent toggling when clicking inside dropdown list itself
							if (e.target.closest('.dropdown ul')) return;

							// Close other open dropdowns first (optional)
							document.querySelectorAll('.filter.open').forEach(openFilter => {
							if (openFilter !== filter) openFilter.classList.remove('open');
							});

							// Toggle current filter open class
							filter.classList.toggle('open');
						});
					});

					// Optional: Close dropdowns if clicked outside
					document.addEventListener('click', e => {
						if (!e.target.closest('.filter')) {
							document.querySelectorAll('.filter.open').forEach(openFilter => {
							openFilter.classList.remove('open');
							});
						}
					});

					// Function to resize the globe based on its container size
					const resizeGlobe = () => {
						const container = document.getElementById('globe');
						// Set the width and height of the globe based on the container's size
						globe.width(container.offsetWidth).height(container.offsetHeight);
						
						// Manually reset the canvas element size to match the container size
						const canvas = document.querySelector('canvas');
						canvas.style.width = `${container.offsetWidth}px`;
						canvas.style.height = `${container.offsetHeight}px`;
						canvas.style.transform = 'none';
					};

				</script> 

				<a href="#">Go to Top</a>
				<br>
				<br>
				<h2>Frequently Asked Questions</h2>

				<div id="faqs-container"></div>

				<script>
					const faqData = [ 
						{ question: "What are these chemicals?",
							answer: "NO<sub>x</sub> is nitrogen oxides, BC is black carbon or soot, and Cl<sub>y</sub> is a family of chlorine compounds. AlO<sub>x</sub> is a family of oxidised aluminium compounds produced as metal objects re-enter the Earth's atmosphere. The current scientific understanding is that this is a mixture of aerosol phase aluminium oxide (alumina, Al<sub>2</sub>O<sub>3</sub>) and aluminium hydroxide (Al(OH)<sub>3</sub>). NO<sub>x</sub> and Cl<sub>y</sub> are released as gases, while BC and AlO<sub>x</sub> are released as particles."
						},
						{ question: "How do these chemicals affect the atmosphere?",
							answer: "Re-entries release air pollutant emissions into the upper layers of the atmosphere, where they can have an outsized impact on our atmosphere and climate. NO<sub>x</sub> and Cl<sub>y</sub> are the largest contributors to destruction of the ozone layer from rocket emissions, with smaller destruction occuring from emissions of BC and AlO<sub>x</sub>. The largest climate impacts come from BC emissions, which warm the upper layers of the atmosphere while cooling the lower layers."
						},
						{ question: "What does each filter represent?",
							answer: "Re-entry point allows users to filter for re-entering objects that are known and that we have had to approximate, as exact location data is not available. Known re-entries are further separated into Falcon and non-Falcon rocket and fairing re-entries.  Object Type distinguishes individual re-entering objects as Payload (P), C=Component (C1), Booster (B1-B4), and rocket stage (S1-S4). Megaconstellation allows users to select re-entries that are or are not associated with megaconstellation missions."
						},
						{ question: "How is this data calculated?",
							answer: "Our calculations are based on the current best scientific knowledge available for emissions from object re-entries. We use object-specific ablation profiles to calculate AlO<sub>x</sub> emissions from object re-entries, including all objects with an apogee above 50 km. Paths shown in the Globe view are fixed at the re-entry location and do not represent real object trajectories."
						},
						{ question: "Where can I find the original methodology and data?",
						answer: "You can find further details in our study published in Nature Scientific Data: Global 3D rocket launch and re-entry air pollutant and carbon dioxide emissions for 2020-2022</strong>. C. R. Barker, E. A. Marais (2024). doi:10.5522/04/26325382. [<a href='https://doi.org/10.5522/04/26325382' target='_blank' rel='noopener noreferrer'>Data</a>]. [<a href='https://www.nature.com/articles/s41597-024-03910-z' target='_blank' rel='noopener noreferrer'>Publication</a>]</p>"
						}
					];

					const faqsContainer = document.getElementById('faqs-container');

					faqData.map(function(item) {

						let article = document.createElement('article');
						article.classList.add('faq-item');

						const markup = `
								<div class="item-question">
									<span class="question-text">${item.question}</span>
									<span class="arrows-container">
										<span class="expand">▼</span>
										<span class="close">▲</span>
									</span>
								</div>
								<div class="item-answer">
									<span>${item.answer}</span>
								</div>
						`;
						
						article.innerHTML = markup;
						faqsContainer.append(article);
					});

					const toggleButtons = document.querySelectorAll('.arrows-container');
						
					toggleButtons.forEach(button => {
						button.addEventListener('click', function(e) {
							const faqItem = e.currentTarget.parentElement.parentElement;
							faqItem.classList.toggle("show-answer");
						});
					});

				</script>
				<br>
				<p>
					Developed by <a href="https://profiles.ucl.ac.uk/93616-connor-barker" target="_blank" rel="noopener noreferrer">Connor Barker</a> (UCL postdoc) and <a href="https://profiles.ucl.ac.uk/77783-eloise-marais" target="_blank" rel="noopener noreferrer">Eloise Marais</a> (UCL PI), in collaboration with <a href="https://www.cfa.harvard.edu/people/jonathan-mcdowell" target="_blank" rel="noopener noreferrer">Jonathan McDowell</a> (Harvard-Smithsonian Center for Astrophysics) and Eric Tan (UCL Department of Astrophysics). Interested in using the data or spot any room for improvements? Please reach out to Connor Barker at <a href= "mailto:name@email.com">connor.barker@ucl.ac.uk</a>.
				</p>
				<p>
					<strong>Funding Disclaimer:</strong> This project has received funding from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (grant agreement No. 851854). <a href="https://cordis.europa.eu/project/id/851854" target="_blank" rel="noopener noreferrer">European Commission project page</a>.
				</p>
			</div>
		</div>
	</div>

	<hr />
	<div id="footer">
		<p>
			<br> <br />
		</p>
	</div>
	<script type="text/javascript' src='./js/wp-embed.min.js"></script>
</body>
</html>